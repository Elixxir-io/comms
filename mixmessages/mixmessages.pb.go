// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mixmessages.proto

/*
Package mixmessages is a generated protocol buffer package.

It is generated from these files:
	mixmessages.proto

It has these top-level messages:
	Ping
	TimePing
	ServerMetricsMessage
	InitRound
	RoundBufferInfo
	ClientPollMessage
	ClientMessages
	PublicKeyMessage
	InputMessages
	OutputMessages
	RegisterUserMessage
	ConfirmRegisterUserMessage
	RequestNonceMessage
	NonceMessage
	ConfirmNonceMessage
	RegistrationConfirmation
	Ack
	CmixMessage
	PrecompDecryptSlot
	PrecompDecryptMessage
	PrecompEncryptSlot
	PrecompEncryptMessage
	PrecompRevealSlot
	PrecompRevealMessage
	PrecompPermuteSlot
	PrecompPermuteMessage
	PrecompShareInitMessage
	PrecompShareCompareMessage
	PrecompShareConfirmMessage
	PrecompShareSlot
	PrecompShareMessage
	RealtimeDecryptMessage
	RealtimeEncryptMessage
	RealtimePermuteSlot
	RealtimePermuteMessage
*/
package mixmessages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request message asking if server is online
type Ping struct {
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The request message asking server to add their time
type TimePing struct {
	Times []int64 `protobuf:"varint,1,rep,packed,name=Times" json:"Times,omitempty"`
}

func (m *TimePing) Reset()                    { *m = TimePing{} }
func (m *TimePing) String() string            { return proto.CompactTextString(m) }
func (*TimePing) ProtoMessage()               {}
func (*TimePing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TimePing) GetTimes() []int64 {
	if m != nil {
		return m.Times
	}
	return nil
}

// The message containing the server metrics from all visited nodes
type ServerMetricsMessage struct {
	MemUsage    []uint32 `protobuf:"varint,1,rep,packed,name=MemUsage" json:"MemUsage,omitempty"`
	ThreadUsage []uint32 `protobuf:"varint,2,rep,packed,name=ThreadUsage" json:"ThreadUsage,omitempty"`
	CpuUsage    []uint32 `protobuf:"varint,3,rep,packed,name=CpuUsage" json:"CpuUsage,omitempty"`
	UpSince     []int64  `protobuf:"varint,4,rep,packed,name=UpSince" json:"UpSince,omitempty"`
}

func (m *ServerMetricsMessage) Reset()                    { *m = ServerMetricsMessage{} }
func (m *ServerMetricsMessage) String() string            { return proto.CompactTextString(m) }
func (*ServerMetricsMessage) ProtoMessage()               {}
func (*ServerMetricsMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ServerMetricsMessage) GetMemUsage() []uint32 {
	if m != nil {
		return m.MemUsage
	}
	return nil
}

func (m *ServerMetricsMessage) GetThreadUsage() []uint32 {
	if m != nil {
		return m.ThreadUsage
	}
	return nil
}

func (m *ServerMetricsMessage) GetCpuUsage() []uint32 {
	if m != nil {
		return m.CpuUsage
	}
	return nil
}

func (m *ServerMetricsMessage) GetUpSince() []int64 {
	if m != nil {
		return m.UpSince
	}
	return nil
}

// The message for Init Round
type InitRound struct {
	RoundID string `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
}

func (m *InitRound) Reset()                    { *m = InitRound{} }
func (m *InitRound) String() string            { return proto.CompactTextString(m) }
func (*InitRound) ProtoMessage()               {}
func (*InitRound) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *InitRound) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

// RoundInfo contains the # of precomputations ready for messages, among other
// information
type RoundBufferInfo struct {
	RoundBufferSize uint32 `protobuf:"varint,1,opt,name=RoundBufferSize" json:"RoundBufferSize,omitempty"`
}

func (m *RoundBufferInfo) Reset()                    { *m = RoundBufferInfo{} }
func (m *RoundBufferInfo) String() string            { return proto.CompactTextString(m) }
func (*RoundBufferInfo) ProtoMessage()               {}
func (*RoundBufferInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RoundBufferInfo) GetRoundBufferSize() uint32 {
	if m != nil {
		return m.RoundBufferSize
	}
	return 0
}

// The message for clients to poll new CMIX messages
type ClientPollMessage struct {
	UserID    []byte `protobuf:"bytes,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MessageID string `protobuf:"bytes,2,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *ClientPollMessage) Reset()                    { *m = ClientPollMessage{} }
func (m *ClientPollMessage) String() string            { return proto.CompactTextString(m) }
func (*ClientPollMessage) ProtoMessage()               {}
func (*ClientPollMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ClientPollMessage) GetUserID() []byte {
	if m != nil {
		return m.UserID
	}
	return nil
}

func (m *ClientPollMessage) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

// The message for clients to poll the gateway for Message IDs
type ClientMessages struct {
	MessageIDs []string `protobuf:"bytes,1,rep,name=MessageIDs" json:"MessageIDs,omitempty"`
}

func (m *ClientMessages) Reset()                    { *m = ClientMessages{} }
func (m *ClientMessages) String() string            { return proto.CompactTextString(m) }
func (*ClientMessages) ProtoMessage()               {}
func (*ClientMessages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ClientMessages) GetMessageIDs() []string {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

// Message for setting public key
type PublicKeyMessage struct {
	RoundID   string `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	PublicKey []byte `protobuf:"bytes,2,opt,name=PublicKey,proto3" json:"PublicKey,omitempty"`
}

func (m *PublicKeyMessage) Reset()                    { *m = PublicKeyMessage{} }
func (m *PublicKeyMessage) String() string            { return proto.CompactTextString(m) }
func (*PublicKeyMessage) ProtoMessage()               {}
func (*PublicKeyMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PublicKeyMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PublicKeyMessage) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// Input messages are a list of messages run as a batch
type InputMessages struct {
	Messages []*CmixMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *InputMessages) Reset()                    { *m = InputMessages{} }
func (m *InputMessages) String() string            { return proto.CompactTextString(m) }
func (*InputMessages) ProtoMessage()               {}
func (*InputMessages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *InputMessages) GetMessages() []*CmixMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

// Output messages are a list of messages run as a batch
type OutputMessages struct {
	Messages []*CmixMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *OutputMessages) Reset()                    { *m = OutputMessages{} }
func (m *OutputMessages) String() string            { return proto.CompactTextString(m) }
func (*OutputMessages) ProtoMessage()               {}
func (*OutputMessages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *OutputMessages) GetMessages() []*CmixMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

// Client -> RegistrationServer message to initialize registration process
type RegisterUserMessage struct {
	RegistrationCode string `protobuf:"bytes,1,opt,name=RegistrationCode" json:"RegistrationCode,omitempty"`
	// Client Public Key
	Y []byte `protobuf:"bytes,2,opt,name=Y,proto3" json:"Y,omitempty"`
	P []byte `protobuf:"bytes,3,opt,name=P,proto3" json:"P,omitempty"`
	Q []byte `protobuf:"bytes,4,opt,name=Q,proto3" json:"Q,omitempty"`
	G []byte `protobuf:"bytes,5,opt,name=G,proto3" json:"G,omitempty"`
}

func (m *RegisterUserMessage) Reset()                    { *m = RegisterUserMessage{} }
func (m *RegisterUserMessage) String() string            { return proto.CompactTextString(m) }
func (*RegisterUserMessage) ProtoMessage()               {}
func (*RegisterUserMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *RegisterUserMessage) GetRegistrationCode() string {
	if m != nil {
		return m.RegistrationCode
	}
	return ""
}

func (m *RegisterUserMessage) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *RegisterUserMessage) GetP() []byte {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RegisterUserMessage) GetQ() []byte {
	if m != nil {
		return m.Q
	}
	return nil
}

func (m *RegisterUserMessage) GetG() []byte {
	if m != nil {
		return m.G
	}
	return nil
}

// RegistrationServer -> Client response to RegisterUserMessage
type ConfirmRegisterUserMessage struct {
	// RegistrationServer-Signed Client Public Key
	Hash  []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
	R     []byte `protobuf:"bytes,2,opt,name=R,proto3" json:"R,omitempty"`
	S     []byte `protobuf:"bytes,3,opt,name=S,proto3" json:"S,omitempty"`
	Error string `protobuf:"bytes,4,opt,name=Error" json:"Error,omitempty"`
}

func (m *ConfirmRegisterUserMessage) Reset()                    { *m = ConfirmRegisterUserMessage{} }
func (m *ConfirmRegisterUserMessage) String() string            { return proto.CompactTextString(m) }
func (*ConfirmRegisterUserMessage) ProtoMessage()               {}
func (*ConfirmRegisterUserMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ConfirmRegisterUserMessage) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ConfirmRegisterUserMessage) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *ConfirmRegisterUserMessage) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *ConfirmRegisterUserMessage) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Client -> Gateway -> Server message to request nonce
type RequestNonceMessage struct {
	Salt []byte `protobuf:"bytes,1,opt,name=Salt,proto3" json:"Salt,omitempty"`
	// Client Public Key
	Y []byte `protobuf:"bytes,2,opt,name=Y,proto3" json:"Y,omitempty"`
	P []byte `protobuf:"bytes,3,opt,name=P,proto3" json:"P,omitempty"`
	Q []byte `protobuf:"bytes,4,opt,name=Q,proto3" json:"Q,omitempty"`
	G []byte `protobuf:"bytes,5,opt,name=G,proto3" json:"G,omitempty"`
	// RegistrationServer-Signed Client Public Key
	Hash []byte `protobuf:"bytes,6,opt,name=Hash,proto3" json:"Hash,omitempty"`
	R    []byte `protobuf:"bytes,7,opt,name=R,proto3" json:"R,omitempty"`
	S    []byte `protobuf:"bytes,8,opt,name=S,proto3" json:"S,omitempty"`
}

func (m *RequestNonceMessage) Reset()                    { *m = RequestNonceMessage{} }
func (m *RequestNonceMessage) String() string            { return proto.CompactTextString(m) }
func (*RequestNonceMessage) ProtoMessage()               {}
func (*RequestNonceMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *RequestNonceMessage) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *RequestNonceMessage) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *RequestNonceMessage) GetP() []byte {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RequestNonceMessage) GetQ() []byte {
	if m != nil {
		return m.Q
	}
	return nil
}

func (m *RequestNonceMessage) GetG() []byte {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *RequestNonceMessage) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *RequestNonceMessage) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *RequestNonceMessage) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

// Server -> Gateway -> Client response to RequestNonceMessage
type NonceMessage struct {
	Nonce []byte `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=Error" json:"Error,omitempty"`
}

func (m *NonceMessage) Reset()                    { *m = NonceMessage{} }
func (m *NonceMessage) String() string            { return proto.CompactTextString(m) }
func (*NonceMessage) ProtoMessage()               {}
func (*NonceMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *NonceMessage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *NonceMessage) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Client -> Gateway -> Server message to confirm nonce
type ConfirmNonceMessage struct {
	// Client-Signed Nonce
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
	R    []byte `protobuf:"bytes,2,opt,name=R,proto3" json:"R,omitempty"`
	S    []byte `protobuf:"bytes,3,opt,name=S,proto3" json:"S,omitempty"`
}

func (m *ConfirmNonceMessage) Reset()                    { *m = ConfirmNonceMessage{} }
func (m *ConfirmNonceMessage) String() string            { return proto.CompactTextString(m) }
func (*ConfirmNonceMessage) ProtoMessage()               {}
func (*ConfirmNonceMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ConfirmNonceMessage) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ConfirmNonceMessage) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *ConfirmNonceMessage) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

// Server -> Gateway -> Client response to ConfirmNonceMessage
type RegistrationConfirmation struct {
	// Server-Signed Client Public Key
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
	R    []byte `protobuf:"bytes,2,opt,name=R,proto3" json:"R,omitempty"`
	S    []byte `protobuf:"bytes,3,opt,name=S,proto3" json:"S,omitempty"`
	// Server Public Key
	Y     []byte `protobuf:"bytes,4,opt,name=Y,proto3" json:"Y,omitempty"`
	P     []byte `protobuf:"bytes,5,opt,name=P,proto3" json:"P,omitempty"`
	Q     []byte `protobuf:"bytes,6,opt,name=Q,proto3" json:"Q,omitempty"`
	G     []byte `protobuf:"bytes,7,opt,name=G,proto3" json:"G,omitempty"`
	Error string `protobuf:"bytes,8,opt,name=Error" json:"Error,omitempty"`
}

func (m *RegistrationConfirmation) Reset()                    { *m = RegistrationConfirmation{} }
func (m *RegistrationConfirmation) String() string            { return proto.CompactTextString(m) }
func (*RegistrationConfirmation) ProtoMessage()               {}
func (*RegistrationConfirmation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *RegistrationConfirmation) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *RegistrationConfirmation) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *RegistrationConfirmation) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *RegistrationConfirmation) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *RegistrationConfirmation) GetP() []byte {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *RegistrationConfirmation) GetQ() []byte {
	if m != nil {
		return m.Q
	}
	return nil
}

func (m *RegistrationConfirmation) GetG() []byte {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *RegistrationConfirmation) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Generic Ack message containing an Error field
type Ack struct {
	Error string `protobuf:"bytes,1,opt,name=Error" json:"Error,omitempty"`
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Ack) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// The standard CMIX message type
type CmixMessage struct {
	SenderID       []byte `protobuf:"bytes,1,opt,name=SenderID,proto3" json:"SenderID,omitempty"`
	MessagePayload []byte `protobuf:"bytes,2,opt,name=MessagePayload,proto3" json:"MessagePayload,omitempty"`
	// TODO When we increase the size of the prime, the payload and associated
	// data should become part of the
	AssociatedData []byte   `protobuf:"bytes,3,opt,name=AssociatedData,proto3" json:"AssociatedData,omitempty"`
	Salt           []byte   `protobuf:"bytes,4,opt,name=Salt,proto3" json:"Salt,omitempty"`
	KMACs          [][]byte `protobuf:"bytes,5,rep,name=KMACs,proto3" json:"KMACs,omitempty"`
}

func (m *CmixMessage) Reset()                    { *m = CmixMessage{} }
func (m *CmixMessage) String() string            { return proto.CompactTextString(m) }
func (*CmixMessage) ProtoMessage()               {}
func (*CmixMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CmixMessage) GetSenderID() []byte {
	if m != nil {
		return m.SenderID
	}
	return nil
}

func (m *CmixMessage) GetMessagePayload() []byte {
	if m != nil {
		return m.MessagePayload
	}
	return nil
}

func (m *CmixMessage) GetAssociatedData() []byte {
	if m != nil {
		return m.AssociatedData
	}
	return nil
}

func (m *CmixMessage) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *CmixMessage) GetKMACs() [][]byte {
	if m != nil {
		return m.KMACs
	}
	return nil
}

// Message for individual Precomp Decrypt Slot
type PrecompDecryptSlot struct {
	Slot                            uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessageKeys            []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	EncryptedAssociatedDataKeys     []byte `protobuf:"bytes,3,opt,name=EncryptedAssociatedDataKeys,proto3" json:"EncryptedAssociatedDataKeys,omitempty"`
	PartialMessageCypherText        []byte `protobuf:"bytes,4,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialAssociatedDataCypherText []byte `protobuf:"bytes,5,opt,name=PartialAssociatedDataCypherText,proto3" json:"PartialAssociatedDataCypherText,omitempty"`
}

func (m *PrecompDecryptSlot) Reset()                    { *m = PrecompDecryptSlot{} }
func (m *PrecompDecryptSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompDecryptSlot) ProtoMessage()               {}
func (*PrecompDecryptSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *PrecompDecryptSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompDecryptSlot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *PrecompDecryptSlot) GetEncryptedAssociatedDataKeys() []byte {
	if m != nil {
		return m.EncryptedAssociatedDataKeys
	}
	return nil
}

func (m *PrecompDecryptSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *PrecompDecryptSlot) GetPartialAssociatedDataCypherText() []byte {
	if m != nil {
		return m.PartialAssociatedDataCypherText
	}
	return nil
}

// Message for batch of Precomp Decrypt Slots
type PrecompDecryptMessage struct {
	RoundID string                `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                 `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompDecryptSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompDecryptMessage) Reset()                    { *m = PrecompDecryptMessage{} }
func (m *PrecompDecryptMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompDecryptMessage) ProtoMessage()               {}
func (*PrecompDecryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *PrecompDecryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompDecryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompDecryptMessage) GetSlots() []*PrecompDecryptSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Precomp Encrypt Slot
type PrecompEncryptSlot struct {
	Slot                     uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessageKeys     []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	PartialMessageCypherText []byte `protobuf:"bytes,3,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
}

func (m *PrecompEncryptSlot) Reset()                    { *m = PrecompEncryptSlot{} }
func (m *PrecompEncryptSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompEncryptSlot) ProtoMessage()               {}
func (*PrecompEncryptSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PrecompEncryptSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompEncryptSlot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *PrecompEncryptSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

// Message for batch of Precomp Encrypt Slots
type PrecompEncryptMessage struct {
	RoundID string                `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                 `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompEncryptSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompEncryptMessage) Reset()                    { *m = PrecompEncryptMessage{} }
func (m *PrecompEncryptMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompEncryptMessage) ProtoMessage()               {}
func (*PrecompEncryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *PrecompEncryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompEncryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompEncryptMessage) GetSlots() []*PrecompEncryptSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Precomp Reveal Slot
type PrecompRevealSlot struct {
	Slot                            uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	PartialMessageCypherText        []byte `protobuf:"bytes,2,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialAssociatedDataCypherText []byte `protobuf:"bytes,3,opt,name=PartialAssociatedDataCypherText,proto3" json:"PartialAssociatedDataCypherText,omitempty"`
}

func (m *PrecompRevealSlot) Reset()                    { *m = PrecompRevealSlot{} }
func (m *PrecompRevealSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompRevealSlot) ProtoMessage()               {}
func (*PrecompRevealSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *PrecompRevealSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompRevealSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *PrecompRevealSlot) GetPartialAssociatedDataCypherText() []byte {
	if m != nil {
		return m.PartialAssociatedDataCypherText
	}
	return nil
}

// Message for batch of Precomp Reveal Slots
type PrecompRevealMessage struct {
	RoundID string               `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompRevealSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompRevealMessage) Reset()                    { *m = PrecompRevealMessage{} }
func (m *PrecompRevealMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompRevealMessage) ProtoMessage()               {}
func (*PrecompRevealMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *PrecompRevealMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompRevealMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompRevealMessage) GetSlots() []*PrecompRevealSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Precomp Permute Slot
type PrecompPermuteSlot struct {
	Slot                            uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessageKeys            []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	EncryptedAssociatedDataKeys     []byte `protobuf:"bytes,3,opt,name=EncryptedAssociatedDataKeys,proto3" json:"EncryptedAssociatedDataKeys,omitempty"`
	PartialMessageCypherText        []byte `protobuf:"bytes,4,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialAssociatedDataCypherText []byte `protobuf:"bytes,5,opt,name=PartialAssociatedDataCypherText,proto3" json:"PartialAssociatedDataCypherText,omitempty"`
}

func (m *PrecompPermuteSlot) Reset()                    { *m = PrecompPermuteSlot{} }
func (m *PrecompPermuteSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompPermuteSlot) ProtoMessage()               {}
func (*PrecompPermuteSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *PrecompPermuteSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompPermuteSlot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *PrecompPermuteSlot) GetEncryptedAssociatedDataKeys() []byte {
	if m != nil {
		return m.EncryptedAssociatedDataKeys
	}
	return nil
}

func (m *PrecompPermuteSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *PrecompPermuteSlot) GetPartialAssociatedDataCypherText() []byte {
	if m != nil {
		return m.PartialAssociatedDataCypherText
	}
	return nil
}

// Message for batch of Precomp Permute Slots
type PrecompPermuteMessage struct {
	RoundID string                `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                 `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompPermuteSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompPermuteMessage) Reset()                    { *m = PrecompPermuteMessage{} }
func (m *PrecompPermuteMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompPermuteMessage) ProtoMessage()               {}
func (*PrecompPermuteMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *PrecompPermuteMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompPermuteMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompPermuteMessage) GetSlots() []*PrecompPermuteSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message from last node to indicate share phase is beginning
type PrecompShareInitMessage struct {
	RoundID       string `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	NodeID        uint64 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	SignedRoundID []byte `protobuf:"bytes,3,opt,name=SignedRoundID,proto3" json:"SignedRoundID,omitempty"`
}

func (m *PrecompShareInitMessage) Reset()                    { *m = PrecompShareInitMessage{} }
func (m *PrecompShareInitMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareInitMessage) ProtoMessage()               {}
func (*PrecompShareInitMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *PrecompShareInitMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompShareInitMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PrecompShareInitMessage) GetSignedRoundID() []byte {
	if m != nil {
		return m.SignedRoundID
	}
	return nil
}

// Message from each node to every other node to compare results of share phase
type PrecompShareCompareMessage struct {
	RoundCypherKey  []byte `protobuf:"bytes,1,opt,name=RoundCypherKey,proto3" json:"RoundCypherKey,omitempty"`
	NodeID          uint64 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	SignedCypherKey []byte `protobuf:"bytes,3,opt,name=SignedCypherKey,proto3" json:"SignedCypherKey,omitempty"`
}

func (m *PrecompShareCompareMessage) Reset()                    { *m = PrecompShareCompareMessage{} }
func (m *PrecompShareCompareMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareCompareMessage) ProtoMessage()               {}
func (*PrecompShareCompareMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *PrecompShareCompareMessage) GetRoundCypherKey() []byte {
	if m != nil {
		return m.RoundCypherKey
	}
	return nil
}

func (m *PrecompShareCompareMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PrecompShareCompareMessage) GetSignedCypherKey() []byte {
	if m != nil {
		return m.SignedCypherKey
	}
	return nil
}

// Message from each node after it has confirmed the round cypher key
type PrecompShareConfirmMessage struct {
	HashedCypherKey     []byte `protobuf:"bytes,1,opt,name=HashedCypherKey,proto3" json:"HashedCypherKey,omitempty"`
	NodeID              uint64 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	ComparisonResult    []byte `protobuf:"bytes,3,opt,name=ComparisonResult,proto3" json:"ComparisonResult,omitempty"`
	SignedCypherConfirm []byte `protobuf:"bytes,4,opt,name=SignedCypherConfirm,proto3" json:"SignedCypherConfirm,omitempty"`
}

func (m *PrecompShareConfirmMessage) Reset()                    { *m = PrecompShareConfirmMessage{} }
func (m *PrecompShareConfirmMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareConfirmMessage) ProtoMessage()               {}
func (*PrecompShareConfirmMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *PrecompShareConfirmMessage) GetHashedCypherKey() []byte {
	if m != nil {
		return m.HashedCypherKey
	}
	return nil
}

func (m *PrecompShareConfirmMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PrecompShareConfirmMessage) GetComparisonResult() []byte {
	if m != nil {
		return m.ComparisonResult
	}
	return nil
}

func (m *PrecompShareConfirmMessage) GetSignedCypherConfirm() []byte {
	if m != nil {
		return m.SignedCypherConfirm
	}
	return nil
}

// Message for individual Precomp Share Slot
type PrecompShareSlot struct {
	Slot                        uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	PartialRoundPublicCypherKey []byte `protobuf:"bytes,2,opt,name=PartialRoundPublicCypherKey,proto3" json:"PartialRoundPublicCypherKey,omitempty"`
}

func (m *PrecompShareSlot) Reset()                    { *m = PrecompShareSlot{} }
func (m *PrecompShareSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareSlot) ProtoMessage()               {}
func (*PrecompShareSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *PrecompShareSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompShareSlot) GetPartialRoundPublicCypherKey() []byte {
	if m != nil {
		return m.PartialRoundPublicCypherKey
	}
	return nil
}

// Message for batch of Precomp Share Slots
type PrecompShareMessage struct {
	RoundID string              `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32               `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompShareSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompShareMessage) Reset()                    { *m = PrecompShareMessage{} }
func (m *PrecompShareMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareMessage) ProtoMessage()               {}
func (*PrecompShareMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *PrecompShareMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompShareMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompShareMessage) GetSlots() []*PrecompShareSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for batch of Realtime Decrypt Slots
type RealtimeDecryptMessage struct {
	RoundID string         `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32          `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*CmixMessage `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *RealtimeDecryptMessage) Reset()                    { *m = RealtimeDecryptMessage{} }
func (m *RealtimeDecryptMessage) String() string            { return proto.CompactTextString(m) }
func (*RealtimeDecryptMessage) ProtoMessage()               {}
func (*RealtimeDecryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *RealtimeDecryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *RealtimeDecryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *RealtimeDecryptMessage) GetSlots() []*CmixMessage {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for batch of Realtime Encrypt Slots
type RealtimeEncryptMessage struct {
	RoundID string         `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32          `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*CmixMessage `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *RealtimeEncryptMessage) Reset()                    { *m = RealtimeEncryptMessage{} }
func (m *RealtimeEncryptMessage) String() string            { return proto.CompactTextString(m) }
func (*RealtimeEncryptMessage) ProtoMessage()               {}
func (*RealtimeEncryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *RealtimeEncryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *RealtimeEncryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *RealtimeEncryptMessage) GetSlots() []*CmixMessage {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Realtime Permute Slot
type RealtimePermuteSlot struct {
	Slot                    uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessage        []byte `protobuf:"bytes,2,opt,name=EncryptedMessage,proto3" json:"EncryptedMessage,omitempty"`
	EncryptedAssociatedData []byte `protobuf:"bytes,3,opt,name=EncryptedAssociatedData,proto3" json:"EncryptedAssociatedData,omitempty"`
}

func (m *RealtimePermuteSlot) Reset()                    { *m = RealtimePermuteSlot{} }
func (m *RealtimePermuteSlot) String() string            { return proto.CompactTextString(m) }
func (*RealtimePermuteSlot) ProtoMessage()               {}
func (*RealtimePermuteSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *RealtimePermuteSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *RealtimePermuteSlot) GetEncryptedMessage() []byte {
	if m != nil {
		return m.EncryptedMessage
	}
	return nil
}

func (m *RealtimePermuteSlot) GetEncryptedAssociatedData() []byte {
	if m != nil {
		return m.EncryptedAssociatedData
	}
	return nil
}

// Message for batch of Realtime Permute Slots
type RealtimePermuteMessage struct {
	RoundID string                 `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                  `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*RealtimePermuteSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *RealtimePermuteMessage) Reset()                    { *m = RealtimePermuteMessage{} }
func (m *RealtimePermuteMessage) String() string            { return proto.CompactTextString(m) }
func (*RealtimePermuteMessage) ProtoMessage()               {}
func (*RealtimePermuteMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *RealtimePermuteMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *RealtimePermuteMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *RealtimePermuteMessage) GetSlots() []*RealtimePermuteSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

func init() {
	proto.RegisterType((*Ping)(nil), "mixmessages.Ping")
	proto.RegisterType((*TimePing)(nil), "mixmessages.TimePing")
	proto.RegisterType((*ServerMetricsMessage)(nil), "mixmessages.ServerMetricsMessage")
	proto.RegisterType((*InitRound)(nil), "mixmessages.InitRound")
	proto.RegisterType((*RoundBufferInfo)(nil), "mixmessages.RoundBufferInfo")
	proto.RegisterType((*ClientPollMessage)(nil), "mixmessages.ClientPollMessage")
	proto.RegisterType((*ClientMessages)(nil), "mixmessages.ClientMessages")
	proto.RegisterType((*PublicKeyMessage)(nil), "mixmessages.PublicKeyMessage")
	proto.RegisterType((*InputMessages)(nil), "mixmessages.InputMessages")
	proto.RegisterType((*OutputMessages)(nil), "mixmessages.OutputMessages")
	proto.RegisterType((*RegisterUserMessage)(nil), "mixmessages.RegisterUserMessage")
	proto.RegisterType((*ConfirmRegisterUserMessage)(nil), "mixmessages.ConfirmRegisterUserMessage")
	proto.RegisterType((*RequestNonceMessage)(nil), "mixmessages.RequestNonceMessage")
	proto.RegisterType((*NonceMessage)(nil), "mixmessages.NonceMessage")
	proto.RegisterType((*ConfirmNonceMessage)(nil), "mixmessages.ConfirmNonceMessage")
	proto.RegisterType((*RegistrationConfirmation)(nil), "mixmessages.RegistrationConfirmation")
	proto.RegisterType((*Ack)(nil), "mixmessages.Ack")
	proto.RegisterType((*CmixMessage)(nil), "mixmessages.CmixMessage")
	proto.RegisterType((*PrecompDecryptSlot)(nil), "mixmessages.PrecompDecryptSlot")
	proto.RegisterType((*PrecompDecryptMessage)(nil), "mixmessages.PrecompDecryptMessage")
	proto.RegisterType((*PrecompEncryptSlot)(nil), "mixmessages.PrecompEncryptSlot")
	proto.RegisterType((*PrecompEncryptMessage)(nil), "mixmessages.PrecompEncryptMessage")
	proto.RegisterType((*PrecompRevealSlot)(nil), "mixmessages.PrecompRevealSlot")
	proto.RegisterType((*PrecompRevealMessage)(nil), "mixmessages.PrecompRevealMessage")
	proto.RegisterType((*PrecompPermuteSlot)(nil), "mixmessages.PrecompPermuteSlot")
	proto.RegisterType((*PrecompPermuteMessage)(nil), "mixmessages.PrecompPermuteMessage")
	proto.RegisterType((*PrecompShareInitMessage)(nil), "mixmessages.PrecompShareInitMessage")
	proto.RegisterType((*PrecompShareCompareMessage)(nil), "mixmessages.PrecompShareCompareMessage")
	proto.RegisterType((*PrecompShareConfirmMessage)(nil), "mixmessages.PrecompShareConfirmMessage")
	proto.RegisterType((*PrecompShareSlot)(nil), "mixmessages.PrecompShareSlot")
	proto.RegisterType((*PrecompShareMessage)(nil), "mixmessages.PrecompShareMessage")
	proto.RegisterType((*RealtimeDecryptMessage)(nil), "mixmessages.RealtimeDecryptMessage")
	proto.RegisterType((*RealtimeEncryptMessage)(nil), "mixmessages.RealtimeEncryptMessage")
	proto.RegisterType((*RealtimePermuteSlot)(nil), "mixmessages.RealtimePermuteSlot")
	proto.RegisterType((*RealtimePermuteMessage)(nil), "mixmessages.RealtimePermuteMessage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MixMessageNode service

type MixMessageNodeClient interface {
	// Handles AskOnline
	AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error)
	// Handles RoundtripPing
	RoundtripPing(ctx context.Context, in *TimePing, opts ...grpc.CallOption) (*Ack, error)
	// Handles ServerMetrics
	ServerMetrics(ctx context.Context, in *ServerMetricsMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Init Round
	NewRound(ctx context.Context, in *InitRound, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Decrypt
	PrecompDecrypt(ctx context.Context, in *PrecompDecryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Encrypt
	PrecompEncrypt(ctx context.Context, in *PrecompEncryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Reveal
	PrecompReveal(ctx context.Context, in *PrecompRevealMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Permute
	PrecompPermute(ctx context.Context, in *PrecompPermuteMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share
	PrecompShare(ctx context.Context, in *PrecompShareMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share Initialization
	PrecompShareInit(ctx context.Context, in *PrecompShareInitMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share Comparison
	PrecompShareCompare(ctx context.Context, in *PrecompShareCompareMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share Confirmation
	PrecompShareConfirm(ctx context.Context, in *PrecompShareConfirmMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Realtime Decrypt
	RealtimeDecrypt(ctx context.Context, in *RealtimeDecryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Realtime Encrypt
	RealtimeEncrypt(ctx context.Context, in *RealtimeEncryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Realtime Permute
	RealtimePermute(ctx context.Context, in *RealtimePermuteMessage, opts ...grpc.CallOption) (*Ack, error)
	// Set the public key
	SetPublicKey(ctx context.Context, in *PublicKeyMessage, opts ...grpc.CallOption) (*Ack, error)
	// Starts a new round with these messages (if len(msgs) == batch size)
	StartRound(ctx context.Context, in *InputMessages, opts ...grpc.CallOption) (*Ack, error)
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*RoundBufferInfo, error)
	// Handles Registration Nonce Communication
	RequestNonce(ctx context.Context, in *RequestNonceMessage, opts ...grpc.CallOption) (*NonceMessage, error)
	// Handles Registration Nonce Confirmation
	ConfirmNonce(ctx context.Context, in *ConfirmNonceMessage, opts ...grpc.CallOption) (*RegistrationConfirmation, error)
}

type mixMessageNodeClient struct {
	cc *grpc.ClientConn
}

func NewMixMessageNodeClient(cc *grpc.ClientConn) MixMessageNodeClient {
	return &mixMessageNodeClient{cc}
}

func (c *mixMessageNodeClient) AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/AskOnline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RoundtripPing(ctx context.Context, in *TimePing, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RoundtripPing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) ServerMetrics(ctx context.Context, in *ServerMetricsMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/ServerMetrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) NewRound(ctx context.Context, in *InitRound, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/NewRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompDecrypt(ctx context.Context, in *PrecompDecryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompDecrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompEncrypt(ctx context.Context, in *PrecompEncryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompEncrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompReveal(ctx context.Context, in *PrecompRevealMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompReveal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompPermute(ctx context.Context, in *PrecompPermuteMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompPermute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShare(ctx context.Context, in *PrecompShareMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShareInit(ctx context.Context, in *PrecompShareInitMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShareInit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShareCompare(ctx context.Context, in *PrecompShareCompareMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShareCompare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShareConfirm(ctx context.Context, in *PrecompShareConfirmMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShareConfirm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RealtimeDecrypt(ctx context.Context, in *RealtimeDecryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RealtimeDecrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RealtimeEncrypt(ctx context.Context, in *RealtimeEncryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RealtimeEncrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RealtimePermute(ctx context.Context, in *RealtimePermuteMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RealtimePermute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) SetPublicKey(ctx context.Context, in *PublicKeyMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/SetPublicKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) StartRound(ctx context.Context, in *InputMessages, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/StartRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) GetRoundBufferInfo(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*RoundBufferInfo, error) {
	out := new(RoundBufferInfo)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/GetRoundBufferInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RequestNonce(ctx context.Context, in *RequestNonceMessage, opts ...grpc.CallOption) (*NonceMessage, error) {
	out := new(NonceMessage)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RequestNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) ConfirmNonce(ctx context.Context, in *ConfirmNonceMessage, opts ...grpc.CallOption) (*RegistrationConfirmation, error) {
	out := new(RegistrationConfirmation)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/ConfirmNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MixMessageNode service

type MixMessageNodeServer interface {
	// Handles AskOnline
	AskOnline(context.Context, *Ping) (*Ack, error)
	// Handles RoundtripPing
	RoundtripPing(context.Context, *TimePing) (*Ack, error)
	// Handles ServerMetrics
	ServerMetrics(context.Context, *ServerMetricsMessage) (*Ack, error)
	// Handles Init Round
	NewRound(context.Context, *InitRound) (*Ack, error)
	// Handles Precomp Decrypt
	PrecompDecrypt(context.Context, *PrecompDecryptMessage) (*Ack, error)
	// Handles Precomp Encrypt
	PrecompEncrypt(context.Context, *PrecompEncryptMessage) (*Ack, error)
	// Handles Precomp Reveal
	PrecompReveal(context.Context, *PrecompRevealMessage) (*Ack, error)
	// Handles Precomp Permute
	PrecompPermute(context.Context, *PrecompPermuteMessage) (*Ack, error)
	// Handles Precomp Share
	PrecompShare(context.Context, *PrecompShareMessage) (*Ack, error)
	// Handles Precomp Share Initialization
	PrecompShareInit(context.Context, *PrecompShareInitMessage) (*Ack, error)
	// Handles Precomp Share Comparison
	PrecompShareCompare(context.Context, *PrecompShareCompareMessage) (*Ack, error)
	// Handles Precomp Share Confirmation
	PrecompShareConfirm(context.Context, *PrecompShareConfirmMessage) (*Ack, error)
	// Handles Realtime Decrypt
	RealtimeDecrypt(context.Context, *RealtimeDecryptMessage) (*Ack, error)
	// Handles Realtime Encrypt
	RealtimeEncrypt(context.Context, *RealtimeEncryptMessage) (*Ack, error)
	// Handles Realtime Permute
	RealtimePermute(context.Context, *RealtimePermuteMessage) (*Ack, error)
	// Set the public key
	SetPublicKey(context.Context, *PublicKeyMessage) (*Ack, error)
	// Starts a new round with these messages (if len(msgs) == batch size)
	StartRound(context.Context, *InputMessages) (*Ack, error)
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(context.Context, *Ping) (*RoundBufferInfo, error)
	// Handles Registration Nonce Communication
	RequestNonce(context.Context, *RequestNonceMessage) (*NonceMessage, error)
	// Handles Registration Nonce Confirmation
	ConfirmNonce(context.Context, *ConfirmNonceMessage) (*RegistrationConfirmation, error)
}

func RegisterMixMessageNodeServer(s *grpc.Server, srv MixMessageNodeServer) {
	s.RegisterService(&_MixMessageNode_serviceDesc, srv)
}

func _MixMessageNode_AskOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).AskOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/AskOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).AskOnline(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RoundtripPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimePing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RoundtripPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RoundtripPing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RoundtripPing(ctx, req.(*TimePing))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_ServerMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerMetricsMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).ServerMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/ServerMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).ServerMetrics(ctx, req.(*ServerMetricsMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_NewRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRound)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).NewRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/NewRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).NewRound(ctx, req.(*InitRound))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompDecryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompDecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompDecrypt(ctx, req.(*PrecompDecryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompEncryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompEncrypt(ctx, req.(*PrecompEncryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompReveal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompRevealMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompReveal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompReveal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompReveal(ctx, req.(*PrecompRevealMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompPermute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompPermuteMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompPermute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompPermute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompPermute(ctx, req.(*PrecompPermuteMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShare(ctx, req.(*PrecompShareMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShareInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareInitMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShareInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShareInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShareInit(ctx, req.(*PrecompShareInitMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShareCompare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareCompareMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShareCompare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShareCompare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShareCompare(ctx, req.(*PrecompShareCompareMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShareConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareConfirmMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShareConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShareConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShareConfirm(ctx, req.(*PrecompShareConfirmMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RealtimeDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeDecryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RealtimeDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RealtimeDecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RealtimeDecrypt(ctx, req.(*RealtimeDecryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RealtimeEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeEncryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RealtimeEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RealtimeEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RealtimeEncrypt(ctx, req.(*RealtimeEncryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RealtimePermute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimePermuteMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RealtimePermute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RealtimePermute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RealtimePermute(ctx, req.(*RealtimePermuteMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_SetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKeyMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).SetPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/SetPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).SetPublicKey(ctx, req.(*PublicKeyMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_StartRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).StartRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/StartRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).StartRound(ctx, req.(*InputMessages))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_GetRoundBufferInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).GetRoundBufferInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/GetRoundBufferInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).GetRoundBufferInfo(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RequestNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestNonceMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RequestNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RequestNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RequestNonce(ctx, req.(*RequestNonceMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_ConfirmNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmNonceMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).ConfirmNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/ConfirmNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).ConfirmNonce(ctx, req.(*ConfirmNonceMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _MixMessageNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.MixMessageNode",
	HandlerType: (*MixMessageNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AskOnline",
			Handler:    _MixMessageNode_AskOnline_Handler,
		},
		{
			MethodName: "RoundtripPing",
			Handler:    _MixMessageNode_RoundtripPing_Handler,
		},
		{
			MethodName: "ServerMetrics",
			Handler:    _MixMessageNode_ServerMetrics_Handler,
		},
		{
			MethodName: "NewRound",
			Handler:    _MixMessageNode_NewRound_Handler,
		},
		{
			MethodName: "PrecompDecrypt",
			Handler:    _MixMessageNode_PrecompDecrypt_Handler,
		},
		{
			MethodName: "PrecompEncrypt",
			Handler:    _MixMessageNode_PrecompEncrypt_Handler,
		},
		{
			MethodName: "PrecompReveal",
			Handler:    _MixMessageNode_PrecompReveal_Handler,
		},
		{
			MethodName: "PrecompPermute",
			Handler:    _MixMessageNode_PrecompPermute_Handler,
		},
		{
			MethodName: "PrecompShare",
			Handler:    _MixMessageNode_PrecompShare_Handler,
		},
		{
			MethodName: "PrecompShareInit",
			Handler:    _MixMessageNode_PrecompShareInit_Handler,
		},
		{
			MethodName: "PrecompShareCompare",
			Handler:    _MixMessageNode_PrecompShareCompare_Handler,
		},
		{
			MethodName: "PrecompShareConfirm",
			Handler:    _MixMessageNode_PrecompShareConfirm_Handler,
		},
		{
			MethodName: "RealtimeDecrypt",
			Handler:    _MixMessageNode_RealtimeDecrypt_Handler,
		},
		{
			MethodName: "RealtimeEncrypt",
			Handler:    _MixMessageNode_RealtimeEncrypt_Handler,
		},
		{
			MethodName: "RealtimePermute",
			Handler:    _MixMessageNode_RealtimePermute_Handler,
		},
		{
			MethodName: "SetPublicKey",
			Handler:    _MixMessageNode_SetPublicKey_Handler,
		},
		{
			MethodName: "StartRound",
			Handler:    _MixMessageNode_StartRound_Handler,
		},
		{
			MethodName: "GetRoundBufferInfo",
			Handler:    _MixMessageNode_GetRoundBufferInfo_Handler,
		},
		{
			MethodName: "RequestNonce",
			Handler:    _MixMessageNode_RequestNonce_Handler,
		},
		{
			MethodName: "ConfirmNonce",
			Handler:    _MixMessageNode_ConfirmNonce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// Client API for MixMessageGateway service

type MixMessageGatewayClient interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*ClientMessages, error)
	// Request a CmixMessage from the gateway for the given message information
	GetMessage(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*CmixMessage, error)
	// Put a message on the cMix Gateway
	PutMessage(ctx context.Context, in *CmixMessage, opts ...grpc.CallOption) (*Ack, error)
	// Receives a batch of messages from the server
	ReceiveBatch(ctx context.Context, in *OutputMessages, opts ...grpc.CallOption) (*Ack, error)
	// Pass-through for Registration Nonce Communication
	RequestNonce(ctx context.Context, in *RequestNonceMessage, opts ...grpc.CallOption) (*NonceMessage, error)
	// Pass-through for Registration Nonce Confirmation
	ConfirmNonce(ctx context.Context, in *ConfirmNonceMessage, opts ...grpc.CallOption) (*RegistrationConfirmation, error)
}

type mixMessageGatewayClient struct {
	cc *grpc.ClientConn
}

func NewMixMessageGatewayClient(cc *grpc.ClientConn) MixMessageGatewayClient {
	return &mixMessageGatewayClient{cc}
}

func (c *mixMessageGatewayClient) CheckMessages(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*ClientMessages, error) {
	out := new(ClientMessages)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/CheckMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) GetMessage(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*CmixMessage, error) {
	out := new(CmixMessage)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/GetMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) PutMessage(ctx context.Context, in *CmixMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/PutMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) ReceiveBatch(ctx context.Context, in *OutputMessages, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/ReceiveBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) RequestNonce(ctx context.Context, in *RequestNonceMessage, opts ...grpc.CallOption) (*NonceMessage, error) {
	out := new(NonceMessage)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/RequestNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) ConfirmNonce(ctx context.Context, in *ConfirmNonceMessage, opts ...grpc.CallOption) (*RegistrationConfirmation, error) {
	out := new(RegistrationConfirmation)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/ConfirmNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MixMessageGateway service

type MixMessageGatewayServer interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(context.Context, *ClientPollMessage) (*ClientMessages, error)
	// Request a CmixMessage from the gateway for the given message information
	GetMessage(context.Context, *ClientPollMessage) (*CmixMessage, error)
	// Put a message on the cMix Gateway
	PutMessage(context.Context, *CmixMessage) (*Ack, error)
	// Receives a batch of messages from the server
	ReceiveBatch(context.Context, *OutputMessages) (*Ack, error)
	// Pass-through for Registration Nonce Communication
	RequestNonce(context.Context, *RequestNonceMessage) (*NonceMessage, error)
	// Pass-through for Registration Nonce Confirmation
	ConfirmNonce(context.Context, *ConfirmNonceMessage) (*RegistrationConfirmation, error)
}

func RegisterMixMessageGatewayServer(s *grpc.Server, srv MixMessageGatewayServer) {
	s.RegisterService(&_MixMessageGateway_serviceDesc, srv)
}

func _MixMessageGateway_CheckMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientPollMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).CheckMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/CheckMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).CheckMessages(ctx, req.(*ClientPollMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientPollMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/GetMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).GetMessage(ctx, req.(*ClientPollMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmixMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/PutMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).PutMessage(ctx, req.(*CmixMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_ReceiveBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutputMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).ReceiveBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/ReceiveBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).ReceiveBatch(ctx, req.(*OutputMessages))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_RequestNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestNonceMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).RequestNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/RequestNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).RequestNonce(ctx, req.(*RequestNonceMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_ConfirmNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmNonceMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).ConfirmNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/ConfirmNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).ConfirmNonce(ctx, req.(*ConfirmNonceMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _MixMessageGateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.MixMessageGateway",
	HandlerType: (*MixMessageGatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckMessages",
			Handler:    _MixMessageGateway_CheckMessages_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _MixMessageGateway_GetMessage_Handler,
		},
		{
			MethodName: "PutMessage",
			Handler:    _MixMessageGateway_PutMessage_Handler,
		},
		{
			MethodName: "ReceiveBatch",
			Handler:    _MixMessageGateway_ReceiveBatch_Handler,
		},
		{
			MethodName: "RequestNonce",
			Handler:    _MixMessageGateway_RequestNonce_Handler,
		},
		{
			MethodName: "ConfirmNonce",
			Handler:    _MixMessageGateway_ConfirmNonce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// Client API for Registration service

type RegistrationClient interface {
	// Client & RegistrationServer Communication
	RegisterUser(ctx context.Context, in *RegisterUserMessage, opts ...grpc.CallOption) (*ConfirmRegisterUserMessage, error)
}

type registrationClient struct {
	cc *grpc.ClientConn
}

func NewRegistrationClient(cc *grpc.ClientConn) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) RegisterUser(ctx context.Context, in *RegisterUserMessage, opts ...grpc.CallOption) (*ConfirmRegisterUserMessage, error) {
	out := new(ConfirmRegisterUserMessage)
	err := grpc.Invoke(ctx, "/mixmessages.Registration/RegisterUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registration service

type RegistrationServer interface {
	// Client & RegistrationServer Communication
	RegisterUser(context.Context, *RegisterUserMessage) (*ConfirmRegisterUserMessage, error)
}

func RegisterRegistrationServer(s *grpc.Server, srv RegistrationServer) {
	s.RegisterService(&_Registration_serviceDesc, srv)
}

func _Registration_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterUserMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).RegisterUser(ctx, req.(*RegisterUserMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _Registration_RegisterUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

func init() { proto.RegisterFile("mixmessages.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0xcd, 0x6f, 0x13, 0x47,
	0x14, 0xcf, 0xc6, 0x76, 0x48, 0x5e, 0xec, 0x7c, 0x4c, 0x42, 0x70, 0x1d, 0x0a, 0xee, 0xf0, 0x15,
	0x71, 0x40, 0x28, 0x50, 0x54, 0xd1, 0x4a, 0x25, 0x38, 0x21, 0x04, 0x48, 0x30, 0x6b, 0x38, 0xa0,
	0x9e, 0x16, 0x7b, 0x12, 0xaf, 0x62, 0xef, 0x9a, 0xdd, 0x35, 0x60, 0x54, 0x55, 0x55, 0x0f, 0x3d,
	0xf4, 0x52, 0xf5, 0xd6, 0x7b, 0x7b, 0xed, 0x3f, 0x50, 0xf5, 0xcf, 0xe8, 0x1f, 0x54, 0xcd, 0xd7,
	0xee, 0xcc, 0x7a, 0x76, 0x13, 0x92, 0x72, 0xa8, 0xd4, 0xdb, 0xbc, 0x37, 0x6f, 0xde, 0xc7, 0xef,
	0xbd, 0x79, 0xb3, 0x7e, 0x86, 0xc5, 0xbe, 0xfb, 0xae, 0x4f, 0xc2, 0xd0, 0x39, 0x20, 0xe1, 0x8d,
	0x41, 0xe0, 0x47, 0x3e, 0x9a, 0x55, 0x58, 0x78, 0x0a, 0x8a, 0x4d, 0xd7, 0x3b, 0xc0, 0x75, 0x98,
	0x7e, 0xee, 0xf6, 0x09, 0x5d, 0xa3, 0x65, 0x28, 0xd1, 0x75, 0x58, 0xb5, 0xea, 0x85, 0xb5, 0x82,
	0xcd, 0x09, 0xfc, 0x93, 0x05, 0xcb, 0x2d, 0x12, 0xbc, 0x21, 0xc1, 0x2e, 0x89, 0x02, 0xb7, 0x1d,
	0xee, 0x72, 0x1d, 0xa8, 0x06, 0xd3, 0xbb, 0xa4, 0xff, 0x82, 0xae, 0xd9, 0x89, 0x8a, 0x1d, 0xd3,
	0xa8, 0x0e, 0xb3, 0xcf, 0xbb, 0x01, 0x71, 0x3a, 0x7c, 0x7b, 0x92, 0x6d, 0xab, 0x2c, 0x7a, 0xba,
	0x31, 0x18, 0xf2, 0xed, 0x02, 0x3f, 0x2d, 0x69, 0x54, 0x85, 0x33, 0x2f, 0x06, 0x2d, 0xd7, 0x6b,
	0x93, 0x6a, 0x91, 0xb9, 0x22, 0x49, 0x7c, 0x05, 0x66, 0x76, 0x3c, 0x37, 0xb2, 0xfd, 0xa1, 0xd7,
	0xa1, 0x62, 0x6c, 0xb1, 0xb3, 0x59, 0xb5, 0xea, 0xd6, 0xda, 0x8c, 0x2d, 0x49, 0xfc, 0x25, 0xcc,
	0xb3, 0xe5, 0xfd, 0xe1, 0xfe, 0x3e, 0x09, 0x76, 0xbc, 0x7d, 0x1f, 0xad, 0x69, 0xac, 0x96, 0xfb,
	0x9e, 0xb0, 0x43, 0x15, 0x3b, 0xcd, 0xc6, 0x3b, 0xb0, 0xd8, 0xe8, 0xb9, 0xc4, 0x8b, 0x9a, 0x7e,
	0xaf, 0x27, 0x83, 0x5d, 0x81, 0xa9, 0x17, 0x21, 0x09, 0x84, 0xa9, 0xb2, 0x2d, 0x28, 0x74, 0x1e,
	0x66, 0x84, 0xc8, 0xce, 0x66, 0x75, 0x92, 0x79, 0x91, 0x30, 0xf0, 0x4d, 0x98, 0xe3, 0xaa, 0x04,
	0x2b, 0x44, 0x17, 0x00, 0xe2, 0x6d, 0x0e, 0xf4, 0x8c, 0xad, 0x70, 0xf0, 0x23, 0x58, 0x68, 0x0e,
	0x5f, 0xf5, 0xdc, 0xf6, 0x63, 0x32, 0x92, 0xb6, 0x33, 0xe3, 0xa4, 0xd6, 0x63, 0x69, 0x66, 0xbd,
	0x6c, 0x27, 0x0c, 0xbc, 0x05, 0x95, 0x1d, 0x6f, 0x30, 0x4c, 0x8c, 0xdf, 0xa6, 0x19, 0xe3, 0x6b,
	0x66, 0x7a, 0x76, 0xbd, 0x7a, 0x43, 0xad, 0x93, 0x46, 0xdf, 0x7d, 0x27, 0x04, 0xec, 0x58, 0x12,
	0x3f, 0x80, 0xb9, 0xa7, 0xc3, 0xe8, 0xf4, 0x7a, 0x46, 0xb0, 0x64, 0x93, 0x03, 0x37, 0x8c, 0x48,
	0x40, 0xc1, 0x93, 0xd1, 0x5d, 0x87, 0x05, 0xce, 0x0e, 0x9c, 0xc8, 0xf5, 0xbd, 0x86, 0xdf, 0x21,
	0x22, 0xcc, 0x31, 0x3e, 0x2a, 0x83, 0xf5, 0x52, 0xc4, 0x69, 0xbd, 0xa4, 0x54, 0xb3, 0x5a, 0xe0,
	0x54, 0x93, 0x52, 0xcf, 0xaa, 0x45, 0x4e, 0x3d, 0xa3, 0xd4, 0x76, 0xb5, 0xc4, 0xa9, 0x6d, 0xfc,
	0x0a, 0x6a, 0x0d, 0xdf, 0xdb, 0x77, 0x83, 0xbe, 0xc9, 0x03, 0x04, 0xc5, 0x87, 0x4e, 0xd8, 0x15,
	0x99, 0x65, 0x6b, 0x7a, 0xde, 0x96, 0x96, 0x6c, 0x4a, 0xb5, 0xa4, 0xa5, 0x16, 0xbd, 0x27, 0x5b,
	0x41, 0xe0, 0x07, 0xcc, 0xda, 0x8c, 0xcd, 0x09, 0xfc, 0x8b, 0x45, 0xe3, 0x7b, 0x3d, 0x24, 0x61,
	0xb4, 0xe7, 0x7b, 0x6d, 0xa2, 0x68, 0x6f, 0x39, 0xbd, 0x48, 0x6a, 0xa7, 0xeb, 0x93, 0xc6, 0x11,
	0x7b, 0x3a, 0x95, 0xf6, 0xf4, 0x8c, 0xe6, 0xe9, 0xb4, 0xf0, 0x14, 0xdf, 0x85, 0xb2, 0xe6, 0xcb,
	0x32, 0x94, 0x18, 0x2d, 0x9c, 0xe1, 0x44, 0x12, 0xcf, 0xa4, 0x1a, 0xcf, 0x16, 0x2c, 0x09, 0xcc,
	0xd2, 0xe1, 0x7c, 0x08, 0x58, 0xf8, 0x57, 0x0b, 0xaa, 0x7a, 0x1e, 0x99, 0x4e, 0xb6, 0xfe, 0x60,
	0xe4, 0x19, 0x6e, 0x45, 0x0d, 0xb7, 0x92, 0x86, 0xdb, 0x94, 0x86, 0xdb, 0x19, 0x89, 0x5b, 0x1c,
	0xe1, 0xb4, 0x1a, 0xe1, 0x2a, 0x14, 0x36, 0xda, 0x87, 0xc9, 0xa6, 0xa5, 0x6e, 0xfe, 0x66, 0xc1,
	0xac, 0x52, 0xc7, 0xb4, 0x5f, 0xb5, 0x88, 0xd7, 0x51, 0x5a, 0x40, 0x4c, 0xa3, 0xab, 0x30, 0x27,
	0xc4, 0x9a, 0xce, 0xa8, 0xe7, 0x3b, 0x1d, 0xe1, 0x7f, 0x8a, 0x4b, 0xe5, 0x36, 0xc2, 0xd0, 0x6f,
	0xbb, 0x4e, 0x44, 0x3a, 0x9b, 0x4e, 0xe4, 0x88, 0xc8, 0x52, 0xdc, 0xb8, 0x64, 0x8a, 0x4a, 0xc9,
	0x2c, 0x43, 0xe9, 0xf1, 0xee, 0x46, 0x23, 0xac, 0x96, 0xea, 0x05, 0x9a, 0x3a, 0x46, 0xe0, 0xdf,
	0x27, 0x01, 0x35, 0x03, 0xd2, 0xf6, 0xfb, 0x83, 0x4d, 0xd2, 0x0e, 0x46, 0x83, 0xa8, 0xd5, 0xf3,
	0x23, 0xa6, 0xa0, 0xe7, 0xf3, 0x9a, 0x2b, 0xda, 0x6c, 0x8d, 0xd6, 0x61, 0x79, 0xcb, 0x63, 0x22,
	0xa4, 0x23, 0xfc, 0x7a, 0x4c, 0x46, 0xa1, 0x70, 0xd5, 0xb8, 0x87, 0xee, 0xc1, 0x6a, 0xcc, 0xd7,
	0x7d, 0x64, 0x47, 0xb9, 0xf7, 0x79, 0x22, 0xe8, 0x2e, 0x54, 0x9b, 0x4e, 0x10, 0xb9, 0x8e, 0xec,
	0xa4, 0x8d, 0xd1, 0xa0, 0x4b, 0x82, 0xe7, 0xe4, 0x9d, 0x0c, 0x2f, 0x73, 0x1f, 0x3d, 0x84, 0x8b,
	0x62, 0x4f, 0x57, 0xac, 0xa8, 0xe0, 0xd9, 0x3f, 0x4a, 0x0c, 0x7f, 0x6f, 0xc1, 0x59, 0x1d, 0xa6,
	0xa3, 0x7b, 0xeb, 0x0a, 0x4c, 0x3d, 0x71, 0xc2, 0xe8, 0xe9, 0x80, 0x21, 0x54, 0xb2, 0x05, 0x85,
	0x3e, 0x87, 0x12, 0xc5, 0x33, 0x64, 0xaf, 0xd6, 0xec, 0xfa, 0x45, 0xad, 0xf3, 0x8d, 0xe7, 0xc2,
	0xe6, 0xd2, 0xf4, 0x1e, 0xc8, 0x4c, 0x09, 0xbc, 0xfe, 0xd5, 0x4c, 0xe5, 0xe1, 0x5c, 0xc8, 0xc7,
	0x59, 0x45, 0x47, 0xe8, 0xfe, 0xb8, 0xe8, 0x28, 0xf1, 0x4b, 0x74, 0xfe, 0xb0, 0x60, 0x51, 0xec,
	0xda, 0xe4, 0x0d, 0x71, 0x7a, 0x99, 0xe0, 0xe4, 0x05, 0x3a, 0x79, 0xfa, 0x82, 0x2a, 0x1c, 0xaf,
	0xa0, 0xbe, 0x83, 0x65, 0xcd, 0xdd, 0x93, 0x03, 0x76, 0x5b, 0x07, 0xec, 0x82, 0x09, 0xb0, 0x04,
	0x12, 0x89, 0x97, 0x72, 0xef, 0x9b, 0x24, 0xe8, 0x0f, 0x23, 0xf2, 0xff, 0xbd, 0xcf, 0xbf, 0xf7,
	0x02, 0xa6, 0x8f, 0x5b, 0xd9, 0x4a, 0x2e, 0x64, 0xa6, 0x5e, 0xc3, 0x39, 0xb1, 0xd9, 0xea, 0x3a,
	0x01, 0xa1, 0x5f, 0xaf, 0xc7, 0xf2, 0x61, 0xcf, 0xef, 0xc8, 0x4f, 0xca, 0xa2, 0x2d, 0x28, 0x74,
	0x19, 0x2a, 0x2d, 0xf7, 0xc0, 0x23, 0x1d, 0x79, 0x8e, 0x67, 0x42, 0x67, 0xe2, 0x1f, 0x2d, 0xa8,
	0xa9, 0x36, 0x1b, 0x7e, 0x7f, 0xe0, 0x04, 0x71, 0xe8, 0x57, 0x61, 0x8e, 0x49, 0x72, 0x9c, 0xe8,
	0x97, 0x23, 0x7f, 0xcf, 0x52, 0xdc, 0x4c, 0x27, 0xd6, 0x60, 0x9e, 0xdb, 0x4b, 0x14, 0x70, 0x37,
	0xd2, 0x6c, 0xfc, 0xd7, 0x98, 0x23, 0xec, 0xed, 0x97, 0x8e, 0xac, 0xc1, 0x3c, 0x7d, 0xf1, 0xc9,
	0x98, 0x27, 0x69, 0x76, 0xa6, 0x2b, 0xd7, 0x61, 0x81, 0x07, 0xe7, 0x86, 0xbe, 0x67, 0x93, 0x70,
	0xd8, 0x93, 0x37, 0x78, 0x8c, 0x8f, 0x6e, 0xc2, 0x92, 0xea, 0x9f, 0xf0, 0x45, 0x14, 0xa3, 0x69,
	0x0b, 0x77, 0x61, 0x41, 0xf5, 0x3e, 0xf3, 0x86, 0xdd, 0x83, 0x55, 0x51, 0x88, 0x0c, 0x41, 0xfe,
	0x01, 0x9e, 0xc4, 0xc4, 0x2f, 0x5a, 0x9e, 0x08, 0xfe, 0x16, 0x96, 0x54, 0x4b, 0x27, 0x2f, 0xd2,
	0x5b, 0x7a, 0x91, 0x7e, 0x6a, 0x2a, 0xd2, 0x38, 0x18, 0x59, 0xa2, 0xef, 0x61, 0xc5, 0x26, 0x4e,
	0x2f, 0x72, 0xfb, 0xe4, 0xd4, 0xaf, 0xe3, 0x0d, 0xdd, 0x81, 0xec, 0xdf, 0x05, 0xe3, 0xb6, 0x4f,
	0xfd, 0xf6, 0x7c, 0xa8, 0xed, 0x9f, 0xd9, 0x17, 0x3b, 0x37, 0x7e, 0x54, 0x17, 0xbd, 0x0e, 0x0b,
	0xe9, 0x4e, 0x29, 0x12, 0x3b, 0xc6, 0x47, 0x5f, 0xc0, 0xb9, 0x8c, 0xd6, 0x28, 0x8a, 0x33, 0x6b,
	0x1b, 0xff, 0x60, 0x25, 0x70, 0x9c, 0xba, 0x61, 0xdd, 0xd1, 0xe1, 0xa8, 0x6b, 0x70, 0x18, 0xe2,
	0x16, 0xb0, 0xac, 0xff, 0x39, 0x0b, 0x73, 0xbb, 0x31, 0x58, 0xf4, 0xa6, 0xa1, 0x75, 0x98, 0xd9,
	0x08, 0x0f, 0x9f, 0x7a, 0x3d, 0xd7, 0x23, 0x68, 0x51, 0x2f, 0x2a, 0xd7, 0x3b, 0xa8, 0x2d, 0x68,
	0xac, 0x8d, 0xf6, 0x21, 0x9e, 0x40, 0x77, 0xa1, 0xc2, 0x3c, 0x8c, 0x02, 0x77, 0xc0, 0xc6, 0x0b,
	0x67, 0x35, 0x21, 0x39, 0x75, 0x30, 0x9e, 0x7d, 0x00, 0x15, 0x6d, 0xe4, 0x80, 0x3e, 0xd3, 0x84,
	0x4c, 0xe3, 0x08, 0xa3, 0x9e, 0x3b, 0x30, 0xbd, 0x47, 0xde, 0xf2, 0x69, 0xc1, 0x8a, 0xb6, 0x1f,
	0x4f, 0x11, 0x8c, 0xe7, 0x1e, 0xc2, 0x9c, 0xfe, 0x25, 0x87, 0x70, 0xce, 0x67, 0x5e, 0x9e, 0x07,
	0x89, 0x26, 0x91, 0x73, 0xb3, 0x26, 0xbd, 0xf6, 0xb3, 0x30, 0xd1, 0x3e, 0x07, 0x52, 0x98, 0x98,
	0x3e, 0x47, 0x8e, 0xf0, 0x48, 0xe4, 0xde, 0xec, 0x91, 0x5e, 0x7e, 0x46, 0x4d, 0x9b, 0x50, 0x56,
	0x5b, 0x0a, 0xaa, 0x67, 0x76, 0x9b, 0x3c, 0x2d, 0x4f, 0xf4, 0x2e, 0x4b, 0x13, 0x83, 0x2e, 0x67,
	0x6a, 0x52, 0xde, 0x4f, 0xa3, 0x36, 0x5b, 0xef, 0xa4, 0xe2, 0xe9, 0x43, 0xd7, 0x32, 0x15, 0xea,
	0x8f, 0xe3, 0xf1, 0x74, 0xb2, 0xe7, 0x21, 0x57, 0xa7, 0xfa, 0xce, 0x19, 0x75, 0x3e, 0x82, 0xf9,
	0x54, 0xcf, 0x45, 0x97, 0x8c, 0x17, 0xf4, 0x18, 0x35, 0xa6, 0xe8, 0x92, 0x45, 0x66, 0xd6, 0x75,
	0x8c, 0x2a, 0x53, 0x74, 0xc9, 0xf2, 0xb8, 0x94, 0xd7, 0x38, 0xf2, 0x74, 0x6d, 0x40, 0xb9, 0x45,
	0xa2, 0x78, 0x1e, 0x85, 0x52, 0xaf, 0x51, 0x6a, 0xcc, 0x65, 0x54, 0xf1, 0x15, 0x40, 0x2b, 0x72,
	0x02, 0x31, 0xf0, 0xab, 0xa5, 0xae, 0xb0, 0x32, 0x93, 0x32, 0x9e, 0xde, 0x06, 0xb4, 0x4d, 0xa2,
	0xf4, 0x24, 0xd0, 0xd0, 0xbf, 0xce, 0xeb, 0x21, 0xea, 0x07, 0xf0, 0x04, 0xda, 0x85, 0xb2, 0x3a,
	0xda, 0x41, 0xe9, 0x5e, 0x3a, 0x36, 0xf5, 0xa9, 0x7d, 0xa2, 0x49, 0xa8, 0x5b, 0x78, 0x02, 0xbd,
	0x84, 0xb2, 0x3a, 0x5a, 0x49, 0xa9, 0x33, 0x4c, 0x5d, 0x6a, 0x57, 0x52, 0x06, 0xcd, 0xf3, 0x14,
	0x3c, 0xb1, 0xfe, 0x77, 0x01, 0x16, 0x93, 0xe6, 0xbd, 0xed, 0x44, 0xe4, 0xad, 0x33, 0x42, 0x7b,
	0x50, 0x69, 0x74, 0x49, 0xfb, 0x30, 0x19, 0x43, 0xea, 0x16, 0xd3, 0xe3, 0xce, 0xda, 0xaa, 0x61,
	0x3f, 0x1e, 0xe4, 0xd1, 0x1e, 0x02, 0xdb, 0x24, 0x7e, 0xa9, 0x8f, 0x52, 0x96, 0xf9, 0x10, 0xb3,
	0x57, 0x02, 0x9a, 0xc3, 0xe4, 0xcd, 0xcf, 0x92, 0x34, 0xa6, 0xf7, 0x6b, 0x9a, 0x95, 0x36, 0x71,
	0xdf, 0x90, 0xfb, 0x4e, 0xd4, 0xee, 0x22, 0xdd, 0x69, 0x7d, 0x66, 0x69, 0x54, 0xf0, 0xdf, 0x49,
	0xeb, 0x21, 0xf5, 0x34, 0xd9, 0x45, 0xdf, 0x48, 0x9a, 0x4f, 0x32, 0xc7, 0x3c, 0x1f, 0x1b, 0x72,
	0xd6, 0xae, 0x99, 0x9c, 0x31, 0x08, 0xe2, 0x89, 0x57, 0x53, 0xec, 0xff, 0x82, 0x5b, 0xff, 0x04,
	0x00, 0x00, 0xff, 0xff, 0xd6, 0xcc, 0x6f, 0xb8, 0x44, 0x18, 0x00, 0x00,
}
