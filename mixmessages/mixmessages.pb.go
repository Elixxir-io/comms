// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mixmessages.proto

package mixmessages

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The request message asking if server is online
type Ping struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ping) Reset()         { *m = Ping{} }
func (m *Ping) String() string { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()    {}
func (*Ping) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{0}
}

func (m *Ping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ping.Unmarshal(m, b)
}
func (m *Ping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ping.Marshal(b, m, deterministic)
}
func (m *Ping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ping.Merge(m, src)
}
func (m *Ping) XXX_Size() int {
	return xxx_messageInfo_Ping.Size(m)
}
func (m *Ping) XXX_DiscardUnknown() {
	xxx_messageInfo_Ping.DiscardUnknown(m)
}

var xxx_messageInfo_Ping proto.InternalMessageInfo

// The message for Init Round
type RoundInfo struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoundInfo) Reset()         { *m = RoundInfo{} }
func (m *RoundInfo) String() string { return proto.CompactTextString(m) }
func (*RoundInfo) ProtoMessage()    {}
func (*RoundInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{1}
}

func (m *RoundInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoundInfo.Unmarshal(m, b)
}
func (m *RoundInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoundInfo.Marshal(b, m, deterministic)
}
func (m *RoundInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundInfo.Merge(m, src)
}
func (m *RoundInfo) XXX_Size() int {
	return xxx_messageInfo_RoundInfo.Size(m)
}
func (m *RoundInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoundInfo proto.InternalMessageInfo

func (m *RoundInfo) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// RoundInfo contains the # of precomputations ready for messages, among other
// information
type RoundBufferInfo struct {
	RoundBufferSize      uint32   `protobuf:"varint,1,opt,name=RoundBufferSize,proto3" json:"RoundBufferSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoundBufferInfo) Reset()         { *m = RoundBufferInfo{} }
func (m *RoundBufferInfo) String() string { return proto.CompactTextString(m) }
func (*RoundBufferInfo) ProtoMessage()    {}
func (*RoundBufferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{2}
}

func (m *RoundBufferInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoundBufferInfo.Unmarshal(m, b)
}
func (m *RoundBufferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoundBufferInfo.Marshal(b, m, deterministic)
}
func (m *RoundBufferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundBufferInfo.Merge(m, src)
}
func (m *RoundBufferInfo) XXX_Size() int {
	return xxx_messageInfo_RoundBufferInfo.Size(m)
}
func (m *RoundBufferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundBufferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoundBufferInfo proto.InternalMessageInfo

func (m *RoundBufferInfo) GetRoundBufferSize() uint32 {
	if m != nil {
		return m.RoundBufferSize
	}
	return 0
}

//
type RoundPublicKey struct {
	Round                *RoundInfo `protobuf:"bytes,1,opt,name=Round,proto3" json:"Round,omitempty"`
	Key                  []byte     `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RoundPublicKey) Reset()         { *m = RoundPublicKey{} }
func (m *RoundPublicKey) String() string { return proto.CompactTextString(m) }
func (*RoundPublicKey) ProtoMessage()    {}
func (*RoundPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{3}
}

func (m *RoundPublicKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoundPublicKey.Unmarshal(m, b)
}
func (m *RoundPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoundPublicKey.Marshal(b, m, deterministic)
}
func (m *RoundPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundPublicKey.Merge(m, src)
}
func (m *RoundPublicKey) XXX_Size() int {
	return xxx_messageInfo_RoundPublicKey.Size(m)
}
func (m *RoundPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_RoundPublicKey proto.InternalMessageInfo

func (m *RoundPublicKey) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *RoundPublicKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// Contains network information about all Nodes
type NodeTopology struct {
	Topology             []*NodeInfo `protobuf:"bytes,1,rep,name=Topology,proto3" json:"Topology,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NodeTopology) Reset()         { *m = NodeTopology{} }
func (m *NodeTopology) String() string { return proto.CompactTextString(m) }
func (*NodeTopology) ProtoMessage()    {}
func (*NodeTopology) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{4}
}

func (m *NodeTopology) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeTopology.Unmarshal(m, b)
}
func (m *NodeTopology) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeTopology.Marshal(b, m, deterministic)
}
func (m *NodeTopology) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTopology.Merge(m, src)
}
func (m *NodeTopology) XXX_Size() int {
	return xxx_messageInfo_NodeTopology.Size(m)
}
func (m *NodeTopology) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTopology.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTopology proto.InternalMessageInfo

func (m *NodeTopology) GetTopology() []*NodeInfo {
	if m != nil {
		return m.Topology
	}
	return nil
}

// Contains network information about a single Node
type NodeInfo struct {
	Id                   []byte   `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Index                uint32   `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	IpAddress            string   `protobuf:"bytes,3,opt,name=IpAddress,proto3" json:"IpAddress,omitempty"`
	TlsCert              string   `protobuf:"bytes,4,opt,name=TlsCert,proto3" json:"TlsCert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{5}
}

func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeInfo.Unmarshal(m, b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return xxx_messageInfo_NodeInfo.Size(m)
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *NodeInfo) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *NodeInfo) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *NodeInfo) GetTlsCert() string {
	if m != nil {
		return m.TlsCert
	}
	return ""
}

type RoundMetrics struct {
	RoundMetricJSON      string   `protobuf:"bytes,1,opt,name=RoundMetricJSON,proto3" json:"RoundMetricJSON,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoundMetrics) Reset()         { *m = RoundMetrics{} }
func (m *RoundMetrics) String() string { return proto.CompactTextString(m) }
func (*RoundMetrics) ProtoMessage()    {}
func (*RoundMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{6}
}

func (m *RoundMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoundMetrics.Unmarshal(m, b)
}
func (m *RoundMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoundMetrics.Marshal(b, m, deterministic)
}
func (m *RoundMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoundMetrics.Merge(m, src)
}
func (m *RoundMetrics) XXX_Size() int {
	return xxx_messageInfo_RoundMetrics.Size(m)
}
func (m *RoundMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_RoundMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_RoundMetrics proto.InternalMessageInfo

func (m *RoundMetrics) GetRoundMetricJSON() string {
	if m != nil {
		return m.RoundMetricJSON
	}
	return ""
}

// ClientRequest message for clients to poll new CMIX messages
type ClientRequest struct {
	UserID               []byte   `protobuf:"bytes,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	LastMessageID        string   `protobuf:"bytes,2,opt,name=LastMessageID,proto3" json:"LastMessageID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientRequest) Reset()         { *m = ClientRequest{} }
func (m *ClientRequest) String() string { return proto.CompactTextString(m) }
func (*ClientRequest) ProtoMessage()    {}
func (*ClientRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{7}
}

func (m *ClientRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientRequest.Unmarshal(m, b)
}
func (m *ClientRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientRequest.Marshal(b, m, deterministic)
}
func (m *ClientRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientRequest.Merge(m, src)
}
func (m *ClientRequest) XXX_Size() int {
	return xxx_messageInfo_ClientRequest.Size(m)
}
func (m *ClientRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientRequest proto.InternalMessageInfo

func (m *ClientRequest) GetUserID() []byte {
	if m != nil {
		return m.UserID
	}
	return nil
}

func (m *ClientRequest) GetLastMessageID() string {
	if m != nil {
		return m.LastMessageID
	}
	return ""
}

// The message for clients to poll the gateway for Message IDs
type IDList struct {
	IDs                  []string `protobuf:"bytes,1,rep,name=IDs,proto3" json:"IDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IDList) Reset()         { *m = IDList{} }
func (m *IDList) String() string { return proto.CompactTextString(m) }
func (*IDList) ProtoMessage()    {}
func (*IDList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{8}
}

func (m *IDList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IDList.Unmarshal(m, b)
}
func (m *IDList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IDList.Marshal(b, m, deterministic)
}
func (m *IDList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDList.Merge(m, src)
}
func (m *IDList) XXX_Size() int {
	return xxx_messageInfo_IDList.Size(m)
}
func (m *IDList) XXX_DiscardUnknown() {
	xxx_messageInfo_IDList.DiscardUnknown(m)
}

var xxx_messageInfo_IDList proto.InternalMessageInfo

func (m *IDList) GetIDs() []string {
	if m != nil {
		return m.IDs
	}
	return nil
}

// DSAPublicKey is a public key for the digital signature algorithm
type DSAPublicKey struct {
	Y                    []byte   `protobuf:"bytes,1,opt,name=Y,proto3" json:"Y,omitempty"`
	P                    []byte   `protobuf:"bytes,2,opt,name=P,proto3" json:"P,omitempty"`
	Q                    []byte   `protobuf:"bytes,3,opt,name=Q,proto3" json:"Q,omitempty"`
	G                    []byte   `protobuf:"bytes,4,opt,name=G,proto3" json:"G,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DSAPublicKey) Reset()         { *m = DSAPublicKey{} }
func (m *DSAPublicKey) String() string { return proto.CompactTextString(m) }
func (*DSAPublicKey) ProtoMessage()    {}
func (*DSAPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{9}
}

func (m *DSAPublicKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DSAPublicKey.Unmarshal(m, b)
}
func (m *DSAPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DSAPublicKey.Marshal(b, m, deterministic)
}
func (m *DSAPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DSAPublicKey.Merge(m, src)
}
func (m *DSAPublicKey) XXX_Size() int {
	return xxx_messageInfo_DSAPublicKey.Size(m)
}
func (m *DSAPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_DSAPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_DSAPublicKey proto.InternalMessageInfo

func (m *DSAPublicKey) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *DSAPublicKey) GetP() []byte {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *DSAPublicKey) GetQ() []byte {
	if m != nil {
		return m.Q
	}
	return nil
}

func (m *DSAPublicKey) GetG() []byte {
	if m != nil {
		return m.G
	}
	return nil
}

// RegisterNode to register a node with needed attributes
type NodeRegistration struct {
	ID                   []byte   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	NodeTLSCert          string   `protobuf:"bytes,2,opt,name=NodeTLSCert,proto3" json:"NodeTLSCert,omitempty"`
	GatewayTLSCert       string   `protobuf:"bytes,3,opt,name=GatewayTLSCert,proto3" json:"GatewayTLSCert,omitempty"`
	RegistrationCode     string   `protobuf:"bytes,4,opt,name=RegistrationCode,proto3" json:"RegistrationCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeRegistration) Reset()         { *m = NodeRegistration{} }
func (m *NodeRegistration) String() string { return proto.CompactTextString(m) }
func (*NodeRegistration) ProtoMessage()    {}
func (*NodeRegistration) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{10}
}

func (m *NodeRegistration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeRegistration.Unmarshal(m, b)
}
func (m *NodeRegistration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeRegistration.Marshal(b, m, deterministic)
}
func (m *NodeRegistration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRegistration.Merge(m, src)
}
func (m *NodeRegistration) XXX_Size() int {
	return xxx_messageInfo_NodeRegistration.Size(m)
}
func (m *NodeRegistration) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRegistration.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRegistration proto.InternalMessageInfo

func (m *NodeRegistration) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *NodeRegistration) GetNodeTLSCert() string {
	if m != nil {
		return m.NodeTLSCert
	}
	return ""
}

func (m *NodeRegistration) GetGatewayTLSCert() string {
	if m != nil {
		return m.GatewayTLSCert
	}
	return ""
}

func (m *NodeRegistration) GetRegistrationCode() string {
	if m != nil {
		return m.RegistrationCode
	}
	return ""
}

// DSASignature is a digital signature for the digital signature algorithm
type DSASignature struct {
	Hash                 []byte   `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
	R                    []byte   `protobuf:"bytes,2,opt,name=R,proto3" json:"R,omitempty"`
	S                    []byte   `protobuf:"bytes,3,opt,name=S,proto3" json:"S,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DSASignature) Reset()         { *m = DSASignature{} }
func (m *DSASignature) String() string { return proto.CompactTextString(m) }
func (*DSASignature) ProtoMessage()    {}
func (*DSASignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{11}
}

func (m *DSASignature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DSASignature.Unmarshal(m, b)
}
func (m *DSASignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DSASignature.Marshal(b, m, deterministic)
}
func (m *DSASignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DSASignature.Merge(m, src)
}
func (m *DSASignature) XXX_Size() int {
	return xxx_messageInfo_DSASignature.Size(m)
}
func (m *DSASignature) XXX_DiscardUnknown() {
	xxx_messageInfo_DSASignature.DiscardUnknown(m)
}

var xxx_messageInfo_DSASignature proto.InternalMessageInfo

func (m *DSASignature) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *DSASignature) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *DSASignature) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

// UserRegistration message to initialize registration process
type UserRegistration struct {
	RegistrationCode     string        `protobuf:"bytes,1,opt,name=RegistrationCode,proto3" json:"RegistrationCode,omitempty"`
	Client               *DSAPublicKey `protobuf:"bytes,2,opt,name=Client,proto3" json:"Client,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UserRegistration) Reset()         { *m = UserRegistration{} }
func (m *UserRegistration) String() string { return proto.CompactTextString(m) }
func (*UserRegistration) ProtoMessage()    {}
func (*UserRegistration) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{12}
}

func (m *UserRegistration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRegistration.Unmarshal(m, b)
}
func (m *UserRegistration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRegistration.Marshal(b, m, deterministic)
}
func (m *UserRegistration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRegistration.Merge(m, src)
}
func (m *UserRegistration) XXX_Size() int {
	return xxx_messageInfo_UserRegistration.Size(m)
}
func (m *UserRegistration) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRegistration.DiscardUnknown(m)
}

var xxx_messageInfo_UserRegistration proto.InternalMessageInfo

func (m *UserRegistration) GetRegistrationCode() string {
	if m != nil {
		return m.RegistrationCode
	}
	return ""
}

func (m *UserRegistration) GetClient() *DSAPublicKey {
	if m != nil {
		return m.Client
	}
	return nil
}

// UserRegistrationConfirmation to confirm registration with users
type UserRegistrationConfirmation struct {
	// RegistrationServer-Signed Client Public Key
	ClientSignedByServer *DSASignature `protobuf:"bytes,1,opt,name=ClientSignedByServer,proto3" json:"ClientSignedByServer,omitempty"`
	Error                string        `protobuf:"bytes,2,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UserRegistrationConfirmation) Reset()         { *m = UserRegistrationConfirmation{} }
func (m *UserRegistrationConfirmation) String() string { return proto.CompactTextString(m) }
func (*UserRegistrationConfirmation) ProtoMessage()    {}
func (*UserRegistrationConfirmation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{13}
}

func (m *UserRegistrationConfirmation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRegistrationConfirmation.Unmarshal(m, b)
}
func (m *UserRegistrationConfirmation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRegistrationConfirmation.Marshal(b, m, deterministic)
}
func (m *UserRegistrationConfirmation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRegistrationConfirmation.Merge(m, src)
}
func (m *UserRegistrationConfirmation) XXX_Size() int {
	return xxx_messageInfo_UserRegistrationConfirmation.Size(m)
}
func (m *UserRegistrationConfirmation) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRegistrationConfirmation.DiscardUnknown(m)
}

var xxx_messageInfo_UserRegistrationConfirmation proto.InternalMessageInfo

func (m *UserRegistrationConfirmation) GetClientSignedByServer() *DSASignature {
	if m != nil {
		return m.ClientSignedByServer
	}
	return nil
}

func (m *UserRegistrationConfirmation) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// NonceRequest message to request nonce from client to server
type NonceRequest struct {
	Salt                 []byte        `protobuf:"bytes,1,opt,name=Salt,proto3" json:"Salt,omitempty"`
	Client               *DSAPublicKey `protobuf:"bytes,2,opt,name=Client,proto3" json:"Client,omitempty"`
	ClientSignedByServer *DSASignature `protobuf:"bytes,3,opt,name=ClientSignedByServer,proto3" json:"ClientSignedByServer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NonceRequest) Reset()         { *m = NonceRequest{} }
func (m *NonceRequest) String() string { return proto.CompactTextString(m) }
func (*NonceRequest) ProtoMessage()    {}
func (*NonceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{14}
}

func (m *NonceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NonceRequest.Unmarshal(m, b)
}
func (m *NonceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NonceRequest.Marshal(b, m, deterministic)
}
func (m *NonceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NonceRequest.Merge(m, src)
}
func (m *NonceRequest) XXX_Size() int {
	return xxx_messageInfo_NonceRequest.Size(m)
}
func (m *NonceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NonceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NonceRequest proto.InternalMessageInfo

func (m *NonceRequest) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *NonceRequest) GetClient() *DSAPublicKey {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *NonceRequest) GetClientSignedByServer() *DSASignature {
	if m != nil {
		return m.ClientSignedByServer
	}
	return nil
}

// Nonce message to reply to client from server
type Nonce struct {
	Nonce                []byte   `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Nonce) Reset()         { *m = Nonce{} }
func (m *Nonce) String() string { return proto.CompactTextString(m) }
func (*Nonce) ProtoMessage()    {}
func (*Nonce) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{15}
}

func (m *Nonce) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Nonce.Unmarshal(m, b)
}
func (m *Nonce) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Nonce.Marshal(b, m, deterministic)
}
func (m *Nonce) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Nonce.Merge(m, src)
}
func (m *Nonce) XXX_Size() int {
	return xxx_messageInfo_Nonce.Size(m)
}
func (m *Nonce) XXX_DiscardUnknown() {
	xxx_messageInfo_Nonce.DiscardUnknown(m)
}

var xxx_messageInfo_Nonce proto.InternalMessageInfo

func (m *Nonce) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Nonce) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// RegistrationConfirmation returning proof of registration
type RegistrationConfirmation struct {
	ClientSignedByServer *DSASignature `protobuf:"bytes,1,opt,name=ClientSignedByServer,proto3" json:"ClientSignedByServer,omitempty"`
	Server               *DSAPublicKey `protobuf:"bytes,2,opt,name=Server,proto3" json:"Server,omitempty"`
	Error                string        `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RegistrationConfirmation) Reset()         { *m = RegistrationConfirmation{} }
func (m *RegistrationConfirmation) String() string { return proto.CompactTextString(m) }
func (*RegistrationConfirmation) ProtoMessage()    {}
func (*RegistrationConfirmation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{16}
}

func (m *RegistrationConfirmation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegistrationConfirmation.Unmarshal(m, b)
}
func (m *RegistrationConfirmation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegistrationConfirmation.Marshal(b, m, deterministic)
}
func (m *RegistrationConfirmation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegistrationConfirmation.Merge(m, src)
}
func (m *RegistrationConfirmation) XXX_Size() int {
	return xxx_messageInfo_RegistrationConfirmation.Size(m)
}
func (m *RegistrationConfirmation) XXX_DiscardUnknown() {
	xxx_messageInfo_RegistrationConfirmation.DiscardUnknown(m)
}

var xxx_messageInfo_RegistrationConfirmation proto.InternalMessageInfo

func (m *RegistrationConfirmation) GetClientSignedByServer() *DSASignature {
	if m != nil {
		return m.ClientSignedByServer
	}
	return nil
}

func (m *RegistrationConfirmation) GetServer() *DSAPublicKey {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *RegistrationConfirmation) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Ack generic message containing an Error field
type Ack struct {
	Error                string   `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{17}
}

func (m *Ack) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ack.Unmarshal(m, b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return xxx_messageInfo_Ack.Size(m)
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

func (m *Ack) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Batch struct {
	Round                *RoundInfo `protobuf:"bytes,1,opt,name=Round,proto3" json:"Round,omitempty"`
	FromPhase            int32      `protobuf:"varint,2,opt,name=FromPhase,proto3" json:"FromPhase,omitempty"`
	Slots                []*Slot    `protobuf:"bytes,3,rep,name=slots,proto3" json:"slots,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{18}
}

func (m *Batch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Batch.Unmarshal(m, b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return xxx_messageInfo_Batch.Size(m)
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

func (m *Batch) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *Batch) GetFromPhase() int32 {
	if m != nil {
		return m.FromPhase
	}
	return 0
}

func (m *Batch) GetSlots() []*Slot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Used as part of header for streaming post phase
type BatchInfo struct {
	Round                *RoundInfo `protobuf:"bytes,1,opt,name=Round,proto3" json:"Round,omitempty"`
	FromPhase            int32      `protobuf:"varint,2,opt,name=FromPhase,proto3" json:"FromPhase,omitempty"`
	BatchSize            uint32     `protobuf:"varint,3,opt,name=BatchSize,proto3" json:"BatchSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BatchInfo) Reset()         { *m = BatchInfo{} }
func (m *BatchInfo) String() string { return proto.CompactTextString(m) }
func (*BatchInfo) ProtoMessage()    {}
func (*BatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{19}
}

func (m *BatchInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchInfo.Unmarshal(m, b)
}
func (m *BatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchInfo.Marshal(b, m, deterministic)
}
func (m *BatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchInfo.Merge(m, src)
}
func (m *BatchInfo) XXX_Size() int {
	return xxx_messageInfo_BatchInfo.Size(m)
}
func (m *BatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInfo proto.InternalMessageInfo

func (m *BatchInfo) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *BatchInfo) GetFromPhase() int32 {
	if m != nil {
		return m.FromPhase
	}
	return 0
}

func (m *BatchInfo) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

type Slot struct {
	// Index in batch this slot belongs in
	Index uint32 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	// Precomputation fields
	EncryptedMessageKeys            []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	EncryptedAssociatedDataKeys     []byte `protobuf:"bytes,3,opt,name=EncryptedAssociatedDataKeys,proto3" json:"EncryptedAssociatedDataKeys,omitempty"`
	PartialMessageCypherText        []byte `protobuf:"bytes,4,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialAssociatedDataCypherText []byte `protobuf:"bytes,5,opt,name=PartialAssociatedDataCypherText,proto3" json:"PartialAssociatedDataCypherText,omitempty"`
	PartialRoundPublicCypherKey     []byte `protobuf:"bytes,6,opt,name=PartialRoundPublicCypherKey,proto3" json:"PartialRoundPublicCypherKey,omitempty"`
	// Realtime/client fields
	SenderID             []byte   `protobuf:"bytes,7,opt,name=SenderID,proto3" json:"SenderID,omitempty"`
	MessagePayload       []byte   `protobuf:"bytes,8,opt,name=MessagePayload,proto3" json:"MessagePayload,omitempty"`
	AssociatedData       []byte   `protobuf:"bytes,9,opt,name=AssociatedData,proto3" json:"AssociatedData,omitempty"`
	Salt                 []byte   `protobuf:"bytes,10,opt,name=Salt,proto3" json:"Salt,omitempty"`
	KMACs                [][]byte `protobuf:"bytes,11,rep,name=KMACs,proto3" json:"KMACs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Slot) Reset()         { *m = Slot{} }
func (m *Slot) String() string { return proto.CompactTextString(m) }
func (*Slot) ProtoMessage()    {}
func (*Slot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{20}
}

func (m *Slot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Slot.Unmarshal(m, b)
}
func (m *Slot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Slot.Marshal(b, m, deterministic)
}
func (m *Slot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slot.Merge(m, src)
}
func (m *Slot) XXX_Size() int {
	return xxx_messageInfo_Slot.Size(m)
}
func (m *Slot) XXX_DiscardUnknown() {
	xxx_messageInfo_Slot.DiscardUnknown(m)
}

var xxx_messageInfo_Slot proto.InternalMessageInfo

func (m *Slot) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Slot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *Slot) GetEncryptedAssociatedDataKeys() []byte {
	if m != nil {
		return m.EncryptedAssociatedDataKeys
	}
	return nil
}

func (m *Slot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *Slot) GetPartialAssociatedDataCypherText() []byte {
	if m != nil {
		return m.PartialAssociatedDataCypherText
	}
	return nil
}

func (m *Slot) GetPartialRoundPublicCypherKey() []byte {
	if m != nil {
		return m.PartialRoundPublicCypherKey
	}
	return nil
}

func (m *Slot) GetSenderID() []byte {
	if m != nil {
		return m.SenderID
	}
	return nil
}

func (m *Slot) GetMessagePayload() []byte {
	if m != nil {
		return m.MessagePayload
	}
	return nil
}

func (m *Slot) GetAssociatedData() []byte {
	if m != nil {
		return m.AssociatedData
	}
	return nil
}

func (m *Slot) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *Slot) GetKMACs() [][]byte {
	if m != nil {
		return m.KMACs
	}
	return nil
}

type SignedMessage struct {
	Signature            []byte   `protobuf:"bytes,1,opt,name=Signature,proto3" json:"Signature,omitempty"`
	Message              *any.Any `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignedMessage) Reset()         { *m = SignedMessage{} }
func (m *SignedMessage) String() string { return proto.CompactTextString(m) }
func (*SignedMessage) ProtoMessage()    {}
func (*SignedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f858aeec3eb2fbf5, []int{21}
}

func (m *SignedMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignedMessage.Unmarshal(m, b)
}
func (m *SignedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignedMessage.Marshal(b, m, deterministic)
}
func (m *SignedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedMessage.Merge(m, src)
}
func (m *SignedMessage) XXX_Size() int {
	return xxx_messageInfo_SignedMessage.Size(m)
}
func (m *SignedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SignedMessage proto.InternalMessageInfo

func (m *SignedMessage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedMessage) GetMessage() *any.Any {
	if m != nil {
		return m.Message
	}
	return nil
}

func init() {
	proto.RegisterType((*Ping)(nil), "mixmessages.Ping")
	proto.RegisterType((*RoundInfo)(nil), "mixmessages.RoundInfo")
	proto.RegisterType((*RoundBufferInfo)(nil), "mixmessages.RoundBufferInfo")
	proto.RegisterType((*RoundPublicKey)(nil), "mixmessages.RoundPublicKey")
	proto.RegisterType((*NodeTopology)(nil), "mixmessages.NodeTopology")
	proto.RegisterType((*NodeInfo)(nil), "mixmessages.NodeInfo")
	proto.RegisterType((*RoundMetrics)(nil), "mixmessages.RoundMetrics")
	proto.RegisterType((*ClientRequest)(nil), "mixmessages.ClientRequest")
	proto.RegisterType((*IDList)(nil), "mixmessages.IDList")
	proto.RegisterType((*DSAPublicKey)(nil), "mixmessages.DSAPublicKey")
	proto.RegisterType((*NodeRegistration)(nil), "mixmessages.NodeRegistration")
	proto.RegisterType((*DSASignature)(nil), "mixmessages.DSASignature")
	proto.RegisterType((*UserRegistration)(nil), "mixmessages.UserRegistration")
	proto.RegisterType((*UserRegistrationConfirmation)(nil), "mixmessages.UserRegistrationConfirmation")
	proto.RegisterType((*NonceRequest)(nil), "mixmessages.NonceRequest")
	proto.RegisterType((*Nonce)(nil), "mixmessages.Nonce")
	proto.RegisterType((*RegistrationConfirmation)(nil), "mixmessages.RegistrationConfirmation")
	proto.RegisterType((*Ack)(nil), "mixmessages.Ack")
	proto.RegisterType((*Batch)(nil), "mixmessages.Batch")
	proto.RegisterType((*BatchInfo)(nil), "mixmessages.BatchInfo")
	proto.RegisterType((*Slot)(nil), "mixmessages.Slot")
	proto.RegisterType((*SignedMessage)(nil), "mixmessages.SignedMessage")
}

func init() { proto.RegisterFile("mixmessages.proto", fileDescriptor_f858aeec3eb2fbf5) }

var fileDescriptor_f858aeec3eb2fbf5 = []byte{
	// 1281 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x16, 0xad, 0x83, 0xad, 0xb1, 0xec, 0xd8, 0x1b, 0xff, 0x81, 0x2c, 0x3b, 0xf8, 0x8d, 0x45,
	0x0f, 0x6e, 0x51, 0x38, 0x88, 0x02, 0x14, 0x45, 0xd2, 0x93, 0x2c, 0x25, 0x8e, 0xea, 0xc8, 0x51,
	0x56, 0xe9, 0x45, 0x0a, 0xf4, 0x82, 0x11, 0xc7, 0x12, 0x61, 0x8a, 0x54, 0xb8, 0xab, 0x3a, 0x2a,
	0x7a, 0xd7, 0x97, 0xc8, 0x03, 0xf4, 0xb6, 0x37, 0x7d, 0x98, 0x3e, 0x47, 0x1f, 0xa1, 0xd8, 0x83,
	0xc4, 0x83, 0x28, 0x27, 0x71, 0x8b, 0xde, 0x71, 0x0e, 0x3b, 0xf3, 0xcd, 0xec, 0xcc, 0xec, 0x10,
	0xb6, 0x47, 0xee, 0xeb, 0x11, 0x72, 0x6e, 0x0f, 0x90, 0x1f, 0x8d, 0xc3, 0x40, 0x04, 0x64, 0x3d,
	0xc6, 0xaa, 0xed, 0x0e, 0x82, 0x60, 0xe0, 0xe1, 0x1d, 0x25, 0x7a, 0x39, 0x39, 0xbf, 0x63, 0xfb,
	0x53, 0xad, 0x47, 0x4b, 0x50, 0xe8, 0xba, 0xfe, 0x80, 0xee, 0x41, 0x99, 0x05, 0x13, 0xdf, 0x69,
	0xfb, 0xe7, 0x01, 0xd9, 0x84, 0x95, 0x76, 0xab, 0x6a, 0x1d, 0x58, 0x87, 0x05, 0xb6, 0xd2, 0x6e,
	0xd1, 0x07, 0x70, 0x43, 0x09, 0x8f, 0x27, 0xe7, 0xe7, 0x18, 0x2a, 0x95, 0xc3, 0x04, 0xab, 0xe7,
	0xfe, 0x8c, 0x4a, 0x7f, 0x83, 0xa5, 0xd9, 0xb4, 0x0b, 0x9b, 0x8a, 0xd5, 0x9d, 0xbc, 0xf4, 0xdc,
	0xfe, 0x29, 0x4e, 0xc9, 0x67, 0x50, 0x54, 0x1c, 0x75, 0x62, 0xbd, 0x7e, 0xeb, 0x28, 0x0e, 0x7f,
	0x8e, 0x82, 0x69, 0x25, 0xb2, 0x05, 0xf9, 0x53, 0x9c, 0x56, 0x57, 0x0e, 0xac, 0xc3, 0x0a, 0x93,
	0x9f, 0xb4, 0x01, 0x95, 0xb3, 0xc0, 0xc1, 0xe7, 0xc1, 0x38, 0xf0, 0x82, 0xc1, 0x94, 0xdc, 0x85,
	0xb5, 0xd9, 0x77, 0xd5, 0x3a, 0xc8, 0x1f, 0xae, 0xd7, 0xff, 0x97, 0x30, 0x29, 0x95, 0x95, 0xc5,
	0xb9, 0x1a, 0x1d, 0xc2, 0xda, 0x8c, 0xab, 0xa2, 0xd5, 0x58, 0x2a, 0x6c, 0xa5, 0xed, 0x90, 0x1d,
	0x28, 0xb6, 0x7d, 0x07, 0x5f, 0x2b, 0x97, 0x1b, 0x4c, 0x13, 0x64, 0x1f, 0xca, 0xed, 0x71, 0xc3,
	0x71, 0x42, 0xe4, 0xbc, 0x9a, 0x3f, 0xb0, 0x0e, 0xcb, 0x2c, 0x62, 0x90, 0x2a, 0xac, 0x3e, 0xf7,
	0x78, 0x13, 0x43, 0x51, 0x2d, 0x28, 0xd9, 0x8c, 0xa4, 0x5f, 0x40, 0x45, 0xc5, 0xd1, 0x41, 0x11,
	0xba, 0x7d, 0x3e, 0x4f, 0x9c, 0xa6, 0xbf, 0xeb, 0x3d, 0x3d, 0x53, 0xae, 0xcb, 0x2c, 0xcd, 0xa6,
	0x1d, 0xd8, 0x68, 0x7a, 0x2e, 0xfa, 0x82, 0xe1, 0xab, 0x09, 0x72, 0x41, 0x6e, 0x41, 0xe9, 0x7b,
	0x8e, 0xa1, 0xb9, 0x9a, 0x0a, 0x33, 0x14, 0xf9, 0x00, 0x36, 0x9e, 0xd8, 0x5c, 0x74, 0x74, 0xbc,
	0xed, 0x96, 0x02, 0x5e, 0x66, 0x49, 0x26, 0xad, 0x41, 0xa9, 0xdd, 0x7a, 0xe2, 0x72, 0x21, 0x33,
	0xda, 0x6e, 0x71, 0x95, 0xaa, 0x32, 0x93, 0x9f, 0xf4, 0x11, 0x54, 0x5a, 0xbd, 0x46, 0x74, 0x43,
	0x15, 0xb0, 0x5e, 0x18, 0x27, 0xd6, 0x0b, 0x49, 0x75, 0x4d, 0xfe, 0xad, 0xae, 0xa4, 0x9e, 0xa9,
	0x04, 0x54, 0x98, 0xf5, 0x4c, 0x52, 0x27, 0x2a, 0xe4, 0x0a, 0xb3, 0x4e, 0xe8, 0x1b, 0x0b, 0xb6,
	0x64, 0x5e, 0x19, 0x0e, 0x5c, 0x2e, 0x42, 0x5b, 0xb8, 0x81, 0x1f, 0xab, 0x26, 0x99, 0xdf, 0x16,
	0x39, 0x80, 0x75, 0x75, 0x7d, 0x4f, 0x7a, 0x2a, 0x5f, 0x1a, 0x6c, 0x9c, 0x45, 0x3e, 0x82, 0xcd,
	0x13, 0x5b, 0xe0, 0xa5, 0x3d, 0x9d, 0x29, 0xe9, 0x84, 0xa7, 0xb8, 0xe4, 0x53, 0xd8, 0x8a, 0x7b,
	0x6a, 0x06, 0x0e, 0x9a, 0xf4, 0x2f, 0xf0, 0xe9, 0xd7, 0x2a, 0xc4, 0x9e, 0x3b, 0xf0, 0x6d, 0x31,
	0x09, 0x91, 0x10, 0x28, 0x3c, 0xb6, 0xf9, 0xd0, 0xe0, 0x52, 0xdf, 0x32, 0x18, 0x36, 0x0b, 0x94,
	0x49, 0xaa, 0x37, 0x0b, 0xb4, 0x47, 0x5f, 0xc1, 0x96, 0x4c, 0x77, 0x22, 0xb2, 0x2c, 0xff, 0x56,
	0xb6, 0x7f, 0x72, 0x17, 0x4a, 0xfa, 0x36, 0x95, 0x83, 0xf5, 0xfa, 0x6e, 0xa2, 0x44, 0xe3, 0xd9,
	0x67, 0x46, 0x91, 0xfe, 0x6a, 0xc1, 0x7e, 0xda, 0x67, 0x33, 0xf0, 0xcf, 0xdd, 0x70, 0xa4, 0xfd,
	0x77, 0x60, 0x47, 0xab, 0xca, 0xb0, 0xd0, 0x39, 0x9e, 0xf6, 0x30, 0xfc, 0x09, 0x43, 0xd3, 0x57,
	0x0b, 0x1e, 0xe6, 0xc1, 0xb3, 0xcc, 0x63, 0xb2, 0xf0, 0x1f, 0x86, 0x61, 0x10, 0x9a, 0x2b, 0xd1,
	0x04, 0xfd, 0xcd, 0x92, 0xed, 0xe6, 0xf7, 0x71, 0x56, 0x86, 0x04, 0x0a, 0x3d, 0xdb, 0x13, 0xb3,
	0xcc, 0xc9, 0xef, 0x6b, 0x44, 0xb7, 0x14, 0x7c, 0xfe, 0x5a, 0xe0, 0xe9, 0x3d, 0x28, 0x2a, 0x94,
	0x32, 0x0a, 0xf5, 0x61, 0xf0, 0x45, 0xdc, 0x8c, 0xd8, 0xfe, 0xb0, 0xa0, 0xfa, 0x5f, 0x65, 0xf7,
	0x2e, 0x94, 0x8c, 0x81, 0xb7, 0xa7, 0x28, 0x7d, 0x21, 0xf9, 0x38, 0xe8, 0x3d, 0xc8, 0x37, 0xfa,
	0x17, 0x91, 0xd0, 0x8a, 0x0b, 0x7f, 0x81, 0xe2, 0xb1, 0x2d, 0xfa, 0xc3, 0xf7, 0x1c, 0xb2, 0xfb,
	0x50, 0x7e, 0x14, 0x06, 0xa3, 0xee, 0xd0, 0xe6, 0xa8, 0xf0, 0x15, 0x59, 0xc4, 0x20, 0x1f, 0x43,
	0x91, 0x7b, 0x81, 0x90, 0x73, 0x4f, 0x4e, 0xd7, 0xed, 0x84, 0xad, 0x9e, 0x17, 0x08, 0xa6, 0xe5,
	0x74, 0x02, 0x65, 0xe5, 0x5d, 0xcd, 0xd5, 0x7f, 0x13, 0xc1, 0xbe, 0x31, 0xac, 0x1e, 0x9a, 0xbc,
	0x9a, 0xcb, 0x11, 0x83, 0xfe, 0x95, 0x87, 0x82, 0x84, 0x11, 0x8d, 0x6e, 0x2b, 0x3e, 0xba, 0xeb,
	0xb0, 0xf3, 0xd0, 0xef, 0x87, 0xd3, 0xb1, 0x40, 0xc7, 0xcc, 0xc3, 0x53, 0x9c, 0x72, 0xd3, 0xe9,
	0x99, 0x32, 0xf2, 0x2d, 0xec, 0xcd, 0xf9, 0x0d, 0xce, 0x83, 0xbe, 0x6b, 0x0b, 0x74, 0x5a, 0xb6,
	0xb0, 0xd5, 0x51, 0x3d, 0x16, 0xae, 0x52, 0x21, 0xf7, 0xa1, 0xda, 0xb5, 0x43, 0xe1, 0xda, 0x9e,
	0xb1, 0xdb, 0x9c, 0x8e, 0x87, 0x18, 0x3e, 0xc7, 0xd7, 0xc2, 0x0c, 0xcc, 0xa5, 0x72, 0xf2, 0x18,
	0xfe, 0x6f, 0x64, 0x49, 0xc3, 0x31, 0x13, 0x45, 0x65, 0xe2, 0x6d, 0x6a, 0x32, 0x0e, 0xa3, 0x12,
	0x7b, 0x84, 0xb5, 0x5c, 0xbe, 0xaa, 0x25, 0x1d, 0xc7, 0x15, 0x2a, 0xa4, 0x06, 0x6b, 0x3d, 0xf4,
	0x1d, 0xf5, 0xee, 0xac, 0x2a, 0xf5, 0x39, 0x2d, 0x07, 0xb5, 0x01, 0xdf, 0xb5, 0xa7, 0x5e, 0x60,
	0x3b, 0xd5, 0x35, 0xa5, 0x91, 0xe2, 0x4a, 0xbd, 0x24, 0xc2, 0x6a, 0x59, 0xeb, 0x25, 0xb9, 0xf3,
	0xd1, 0x02, 0xb1, 0xd1, 0xb2, 0x03, 0xc5, 0xd3, 0x4e, 0xa3, 0xc9, 0xab, 0xeb, 0x07, 0x79, 0xd9,
	0xcf, 0x8a, 0xa0, 0x3f, 0xc2, 0x86, 0xee, 0x2f, 0xe3, 0x49, 0x56, 0xc8, 0xbc, 0x03, 0x4d, 0xeb,
	0x47, 0x0c, 0x72, 0x04, 0xab, 0x46, 0xd1, 0x74, 0xdf, 0xce, 0x91, 0xde, 0x89, 0x8e, 0x66, 0x3b,
	0xd1, 0x51, 0xc3, 0x9f, 0xb2, 0x99, 0x52, 0xfd, 0xcd, 0x2a, 0x14, 0xe4, 0x8b, 0x44, 0xea, 0x50,
	0x6e, 0xf0, 0x8b, 0xa7, 0xbe, 0xe7, 0xfa, 0x48, 0x92, 0x85, 0x2f, 0xf7, 0xa6, 0xda, 0x56, 0x82,
	0xd5, 0xe8, 0x5f, 0xd0, 0x1c, 0xf9, 0x12, 0x36, 0x9b, 0x21, 0xda, 0x02, 0xcf, 0xf0, 0x52, 0x17,
	0xf7, 0x92, 0xda, 0xcf, 0x3c, 0xfd, 0x39, 0x54, 0xba, 0x01, 0x17, 0x67, 0x78, 0xa9, 0x1b, 0x99,
	0x24, 0x74, 0x14, 0x6f, 0x99, 0xd7, 0x47, 0xae, 0xef, 0xf2, 0x21, 0x43, 0xdb, 0x13, 0xee, 0x08,
	0xdf, 0xcb, 0xeb, 0x3d, 0x28, 0x4b, 0xaf, 0xba, 0xdb, 0xde, 0xd5, 0xe5, 0x7d, 0xb8, 0xd1, 0x13,
	0x21, 0xda, 0xa3, 0xe8, 0xe8, 0xe2, 0x6c, 0xc8, 0x3a, 0x79, 0x68, 0x11, 0x06, 0xe4, 0x04, 0x45,
	0x7a, 0xad, 0xdc, 0x5f, 0x84, 0x1c, 0x49, 0x6b, 0x57, 0x4a, 0x69, 0x8e, 0x7c, 0x03, 0x15, 0xf3,
	0x48, 0xe9, 0xa1, 0xbf, 0x9b, 0x5a, 0x03, 0xa3, 0x47, 0xac, 0x46, 0x16, 0x45, 0x34, 0x47, 0x5e,
	0xc0, 0x4d, 0xf3, 0x04, 0x24, 0xde, 0xf9, 0xe5, 0xb3, 0xbe, 0xf6, 0x61, 0x12, 0xd2, 0x92, 0xb7,
	0x84, 0xe6, 0xc8, 0x43, 0x20, 0x32, 0x4b, 0xa9, 0x55, 0x78, 0x6f, 0x31, 0xa2, 0xb9, 0x30, 0x33,
	0xe5, 0x0f, 0x60, 0x5b, 0x25, 0x3b, 0xc4, 0x7e, 0x30, 0x1a, 0x33, 0xe4, 0x13, 0x4f, 0xbc, 0x47,
	0x89, 0x6c, 0x9f, 0xa0, 0x68, 0x06, 0xa3, 0xb1, 0x87, 0x02, 0x1d, 0x5d, 0x5f, 0x19, 0x45, 0x9d,
	0x61, 0x8f, 0xe6, 0xc8, 0x31, 0x6c, 0xb5, 0x82, 0x4b, 0x5f, 0x36, 0xf4, 0x7c, 0xf5, 0xae, 0x25,
	0xaf, 0x3b, 0xde, 0x91, 0x99, 0x08, 0x1a, 0x00, 0x27, 0x28, 0x3a, 0x68, 0x73, 0xd9, 0x95, 0xcb,
	0x0a, 0x74, 0x77, 0x91, 0x6f, 0xd6, 0x67, 0x9a, 0xab, 0xff, 0xb9, 0x02, 0xab, 0x66, 0x0f, 0x24,
	0xc7, 0xb0, 0xd1, 0x1c, 0x62, 0xff, 0xc2, 0xb8, 0xe4, 0x29, 0x3c, 0x89, 0xf5, 0xb9, 0x76, 0x33,
	0x21, 0xd3, 0xbb, 0x30, 0xcd, 0x91, 0xaf, 0x0c, 0x24, 0x3d, 0x46, 0xae, 0x32, 0xb0, 0x58, 0xdb,
	0xaa, 0x71, 0xa0, 0x3b, 0x99, 0x1f, 0x7f, 0xb7, 0xf2, 0xff, 0xe7, 0x85, 0xca, 0xa0, 0x62, 0xea,
	0x2b, 0xcb, 0xc0, 0xb5, 0x2a, 0xb4, 0xfe, 0xbb, 0x25, 0x51, 0xc5, 0xca, 0xfe, 0x87, 0x19, 0x8d,
	0xa1, 0x5c, 0x43, 0xc9, 0xed, 0x84, 0xa5, 0xf4, 0x66, 0x5a, 0xfb, 0xe4, 0x4a, 0x71, 0xaa, 0x1d,
	0x1a, 0x91, 0x6d, 0x35, 0x67, 0x6f, 0x2f, 0xfc, 0xb1, 0x25, 0x6c, 0x67, 0x24, 0xf1, 0x65, 0x49,
	0x8d, 0xee, 0x7b, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x65, 0xb2, 0x41, 0xfe, 0x0e, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeClient interface {
	// Handles AskOnline
	AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error)
	// CreatesNewRound makes a new round with a certain ID
	CreateNewRound(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error)
	// PostNewBatch sends a batch to be processed in the server's realtime
	PostNewBatch(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error)
	// FinishRealtime broadcasts when realtime is complete
	FinishRealtime(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error)
	// PostPhase runs a cMix phase on another node
	PostPhase(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error)
	// StreamPostPhase runs a cMix phase on another node
	// by using unary streaming of slots
	StreamPostPhase(ctx context.Context, opts ...grpc.CallOption) (Node_StreamPostPhaseClient, error)
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(ctx context.Context, in *RoundBufferInfo, opts ...grpc.CallOption) (*RoundBufferInfo, error)
	// RequestNonce generates a nonce for user registration
	RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error)
	// ConfirmRegistration uses a nonce confirmation to finalize user registration
	ConfirmRegistration(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error)
	// PostRoundPublicKey sets the public cypher key for a round on other nodes
	PostRoundPublicKey(ctx context.Context, in *RoundPublicKey, opts ...grpc.CallOption) (*Ack, error)
	// PostPrecompResult finalizes the precomputation results with each node from the last node
	// sending the final Message and AD precomputations
	PostPrecompResult(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error)
	// The gateway calls GetCompletedBatch to get any finished batch from a node
	GetCompletedBatch(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Batch, error)
	// Obtains a network topology from the Permissioning Server
	DownloadTopology(ctx context.Context, in *SignedMessage, opts ...grpc.CallOption) (*Ack, error)
	GetMeasure(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*RoundMetrics, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/AskOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CreateNewRound(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/CreateNewRound", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostNewBatch(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/PostNewBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) FinishRealtime(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/FinishRealtime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostPhase(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/PostPhase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) StreamPostPhase(ctx context.Context, opts ...grpc.CallOption) (Node_StreamPostPhaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Node_serviceDesc.Streams[0], "/mixmessages.Node/StreamPostPhase", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeStreamPostPhaseClient{stream}
	return x, nil
}

type Node_StreamPostPhaseClient interface {
	Send(*Slot) error
	CloseAndRecv() (*Ack, error)
	grpc.ClientStream
}

type nodeStreamPostPhaseClient struct {
	grpc.ClientStream
}

func (x *nodeStreamPostPhaseClient) Send(m *Slot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeStreamPostPhaseClient) CloseAndRecv() (*Ack, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) GetRoundBufferInfo(ctx context.Context, in *RoundBufferInfo, opts ...grpc.CallOption) (*RoundBufferInfo, error) {
	out := new(RoundBufferInfo)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/GetRoundBufferInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error) {
	out := new(Nonce)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/RequestNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ConfirmRegistration(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error) {
	out := new(RegistrationConfirmation)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/ConfirmRegistration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostRoundPublicKey(ctx context.Context, in *RoundPublicKey, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/PostRoundPublicKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostPrecompResult(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/PostPrecompResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetCompletedBatch(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Batch, error) {
	out := new(Batch)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/GetCompletedBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DownloadTopology(ctx context.Context, in *SignedMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/DownloadTopology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetMeasure(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*RoundMetrics, error) {
	out := new(RoundMetrics)
	err := c.cc.Invoke(ctx, "/mixmessages.Node/GetMeasure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
type NodeServer interface {
	// Handles AskOnline
	AskOnline(context.Context, *Ping) (*Ack, error)
	// CreatesNewRound makes a new round with a certain ID
	CreateNewRound(context.Context, *RoundInfo) (*Ack, error)
	// PostNewBatch sends a batch to be processed in the server's realtime
	PostNewBatch(context.Context, *Batch) (*Ack, error)
	// FinishRealtime broadcasts when realtime is complete
	FinishRealtime(context.Context, *RoundInfo) (*Ack, error)
	// PostPhase runs a cMix phase on another node
	PostPhase(context.Context, *Batch) (*Ack, error)
	// StreamPostPhase runs a cMix phase on another node
	// by using unary streaming of slots
	StreamPostPhase(Node_StreamPostPhaseServer) error
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(context.Context, *RoundBufferInfo) (*RoundBufferInfo, error)
	// RequestNonce generates a nonce for user registration
	RequestNonce(context.Context, *NonceRequest) (*Nonce, error)
	// ConfirmRegistration uses a nonce confirmation to finalize user registration
	ConfirmRegistration(context.Context, *DSASignature) (*RegistrationConfirmation, error)
	// PostRoundPublicKey sets the public cypher key for a round on other nodes
	PostRoundPublicKey(context.Context, *RoundPublicKey) (*Ack, error)
	// PostPrecompResult finalizes the precomputation results with each node from the last node
	// sending the final Message and AD precomputations
	PostPrecompResult(context.Context, *Batch) (*Ack, error)
	// The gateway calls GetCompletedBatch to get any finished batch from a node
	GetCompletedBatch(context.Context, *Ping) (*Batch, error)
	// Obtains a network topology from the Permissioning Server
	DownloadTopology(context.Context, *SignedMessage) (*Ack, error)
	GetMeasure(context.Context, *RoundInfo) (*RoundMetrics, error)
}

// UnimplementedNodeServer can be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (*UnimplementedNodeServer) AskOnline(ctx context.Context, req *Ping) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AskOnline not implemented")
}
func (*UnimplementedNodeServer) CreateNewRound(ctx context.Context, req *RoundInfo) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewRound not implemented")
}
func (*UnimplementedNodeServer) PostNewBatch(ctx context.Context, req *Batch) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostNewBatch not implemented")
}
func (*UnimplementedNodeServer) FinishRealtime(ctx context.Context, req *RoundInfo) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishRealtime not implemented")
}
func (*UnimplementedNodeServer) PostPhase(ctx context.Context, req *Batch) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostPhase not implemented")
}
func (*UnimplementedNodeServer) StreamPostPhase(srv Node_StreamPostPhaseServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamPostPhase not implemented")
}
func (*UnimplementedNodeServer) GetRoundBufferInfo(ctx context.Context, req *RoundBufferInfo) (*RoundBufferInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoundBufferInfo not implemented")
}
func (*UnimplementedNodeServer) RequestNonce(ctx context.Context, req *NonceRequest) (*Nonce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestNonce not implemented")
}
func (*UnimplementedNodeServer) ConfirmRegistration(ctx context.Context, req *DSASignature) (*RegistrationConfirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmRegistration not implemented")
}
func (*UnimplementedNodeServer) PostRoundPublicKey(ctx context.Context, req *RoundPublicKey) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostRoundPublicKey not implemented")
}
func (*UnimplementedNodeServer) PostPrecompResult(ctx context.Context, req *Batch) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostPrecompResult not implemented")
}
func (*UnimplementedNodeServer) GetCompletedBatch(ctx context.Context, req *Ping) (*Batch, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompletedBatch not implemented")
}
func (*UnimplementedNodeServer) DownloadTopology(ctx context.Context, req *SignedMessage) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadTopology not implemented")
}
func (*UnimplementedNodeServer) GetMeasure(ctx context.Context, req *RoundInfo) (*RoundMetrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMeasure not implemented")
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_AskOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AskOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/AskOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AskOnline(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CreateNewRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CreateNewRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/CreateNewRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CreateNewRound(ctx, req.(*RoundInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostNewBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostNewBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostNewBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostNewBatch(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_FinishRealtime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).FinishRealtime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/FinishRealtime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).FinishRealtime(ctx, req.(*RoundInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostPhase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostPhase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostPhase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostPhase(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_StreamPostPhase_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).StreamPostPhase(&nodeStreamPostPhaseServer{stream})
}

type Node_StreamPostPhaseServer interface {
	SendAndClose(*Ack) error
	Recv() (*Slot, error)
	grpc.ServerStream
}

type nodeStreamPostPhaseServer struct {
	grpc.ServerStream
}

func (x *nodeStreamPostPhaseServer) SendAndClose(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeStreamPostPhaseServer) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Node_GetRoundBufferInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundBufferInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetRoundBufferInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetRoundBufferInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetRoundBufferInfo(ctx, req.(*RoundBufferInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RequestNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RequestNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/RequestNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RequestNonce(ctx, req.(*NonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ConfirmRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSASignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ConfirmRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/ConfirmRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ConfirmRegistration(ctx, req.(*DSASignature))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostRoundPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostRoundPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostRoundPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostRoundPublicKey(ctx, req.(*RoundPublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostPrecompResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostPrecompResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostPrecompResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostPrecompResult(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetCompletedBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetCompletedBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetCompletedBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetCompletedBatch(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DownloadTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DownloadTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/DownloadTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DownloadTopology(ctx, req.(*SignedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetMeasure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetMeasure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetMeasure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetMeasure(ctx, req.(*RoundInfo))
	}
	return interceptor(ctx, in, info, handler)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AskOnline",
			Handler:    _Node_AskOnline_Handler,
		},
		{
			MethodName: "CreateNewRound",
			Handler:    _Node_CreateNewRound_Handler,
		},
		{
			MethodName: "PostNewBatch",
			Handler:    _Node_PostNewBatch_Handler,
		},
		{
			MethodName: "FinishRealtime",
			Handler:    _Node_FinishRealtime_Handler,
		},
		{
			MethodName: "PostPhase",
			Handler:    _Node_PostPhase_Handler,
		},
		{
			MethodName: "GetRoundBufferInfo",
			Handler:    _Node_GetRoundBufferInfo_Handler,
		},
		{
			MethodName: "RequestNonce",
			Handler:    _Node_RequestNonce_Handler,
		},
		{
			MethodName: "ConfirmRegistration",
			Handler:    _Node_ConfirmRegistration_Handler,
		},
		{
			MethodName: "PostRoundPublicKey",
			Handler:    _Node_PostRoundPublicKey_Handler,
		},
		{
			MethodName: "PostPrecompResult",
			Handler:    _Node_PostPrecompResult_Handler,
		},
		{
			MethodName: "GetCompletedBatch",
			Handler:    _Node_GetCompletedBatch_Handler,
		},
		{
			MethodName: "DownloadTopology",
			Handler:    _Node_DownloadTopology_Handler,
		},
		{
			MethodName: "GetMeasure",
			Handler:    _Node_GetMeasure_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPostPhase",
			Handler:       _Node_StreamPostPhase_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "mixmessages.proto",
}

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GatewayClient interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*IDList, error)
	// GetMessage a Batch from the gateway for the given message information
	GetMessage(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*Slot, error)
	// PutMessage on the cMix Gateway
	PutMessage(ctx context.Context, in *Slot, opts ...grpc.CallOption) (*Ack, error)
	// RequestNonce returns a Nonce to the user
	RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error)
	// ConfirmNonce takes a client signed nonce for Registration Nonce Confirmation
	ConfirmNonce(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error)
}

type gatewayClient struct {
	cc *grpc.ClientConn
}

func NewGatewayClient(cc *grpc.ClientConn) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) CheckMessages(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*IDList, error) {
	out := new(IDList)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/CheckMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GetMessage(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*Slot, error) {
	out := new(Slot)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/GetMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PutMessage(ctx context.Context, in *Slot, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/PutMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error) {
	out := new(Nonce)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/RequestNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ConfirmNonce(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error) {
	out := new(RegistrationConfirmation)
	err := c.cc.Invoke(ctx, "/mixmessages.Gateway/ConfirmNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
type GatewayServer interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(context.Context, *ClientRequest) (*IDList, error)
	// GetMessage a Batch from the gateway for the given message information
	GetMessage(context.Context, *ClientRequest) (*Slot, error)
	// PutMessage on the cMix Gateway
	PutMessage(context.Context, *Slot) (*Ack, error)
	// RequestNonce returns a Nonce to the user
	RequestNonce(context.Context, *NonceRequest) (*Nonce, error)
	// ConfirmNonce takes a client signed nonce for Registration Nonce Confirmation
	ConfirmNonce(context.Context, *DSASignature) (*RegistrationConfirmation, error)
}

// UnimplementedGatewayServer can be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (*UnimplementedGatewayServer) CheckMessages(ctx context.Context, req *ClientRequest) (*IDList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckMessages not implemented")
}
func (*UnimplementedGatewayServer) GetMessage(ctx context.Context, req *ClientRequest) (*Slot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessage not implemented")
}
func (*UnimplementedGatewayServer) PutMessage(ctx context.Context, req *Slot) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutMessage not implemented")
}
func (*UnimplementedGatewayServer) RequestNonce(ctx context.Context, req *NonceRequest) (*Nonce, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestNonce not implemented")
}
func (*UnimplementedGatewayServer) ConfirmNonce(ctx context.Context, req *DSASignature) (*RegistrationConfirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmNonce not implemented")
}

func RegisterGatewayServer(s *grpc.Server, srv GatewayServer) {
	s.RegisterService(&_Gateway_serviceDesc, srv)
}

func _Gateway_CheckMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CheckMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/CheckMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CheckMessages(ctx, req.(*ClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/GetMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GetMessage(ctx, req.(*ClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/PutMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PutMessage(ctx, req.(*Slot))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_RequestNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RequestNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/RequestNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RequestNonce(ctx, req.(*NonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ConfirmNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSASignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ConfirmNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/ConfirmNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ConfirmNonce(ctx, req.(*DSASignature))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckMessages",
			Handler:    _Gateway_CheckMessages_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _Gateway_GetMessage_Handler,
		},
		{
			MethodName: "PutMessage",
			Handler:    _Gateway_PutMessage_Handler,
		},
		{
			MethodName: "RequestNonce",
			Handler:    _Gateway_RequestNonce_Handler,
		},
		{
			MethodName: "ConfirmNonce",
			Handler:    _Gateway_ConfirmNonce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// RegistrationClient is the client API for Registration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RegistrationClient interface {
	// Client & RegistrationServer Communication
	RegisterUser(ctx context.Context, in *UserRegistration, opts ...grpc.CallOption) (*UserRegistrationConfirmation, error)
	//Node registration for the permissioning server
	RegisterNode(ctx context.Context, in *NodeRegistration, opts ...grpc.CallOption) (*Ack, error)
}

type registrationClient struct {
	cc *grpc.ClientConn
}

func NewRegistrationClient(cc *grpc.ClientConn) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) RegisterUser(ctx context.Context, in *UserRegistration, opts ...grpc.CallOption) (*UserRegistrationConfirmation, error) {
	out := new(UserRegistrationConfirmation)
	err := c.cc.Invoke(ctx, "/mixmessages.Registration/RegisterUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registrationClient) RegisterNode(ctx context.Context, in *NodeRegistration, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/mixmessages.Registration/RegisterNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegistrationServer is the server API for Registration service.
type RegistrationServer interface {
	// Client & RegistrationServer Communication
	RegisterUser(context.Context, *UserRegistration) (*UserRegistrationConfirmation, error)
	//Node registration for the permissioning server
	RegisterNode(context.Context, *NodeRegistration) (*Ack, error)
}

// UnimplementedRegistrationServer can be embedded to have forward compatible implementations.
type UnimplementedRegistrationServer struct {
}

func (*UnimplementedRegistrationServer) RegisterUser(ctx context.Context, req *UserRegistration) (*UserRegistrationConfirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}
func (*UnimplementedRegistrationServer) RegisterNode(ctx context.Context, req *NodeRegistration) (*Ack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}

func RegisterRegistrationServer(s *grpc.Server, srv RegistrationServer) {
	s.RegisterService(&_Registration_serviceDesc, srv)
}

func _Registration_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).RegisterUser(ctx, req.(*UserRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registration_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/RegisterNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).RegisterNode(ctx, req.(*NodeRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _Registration_RegisterUser_Handler,
		},
		{
			MethodName: "RegisterNode",
			Handler:    _Registration_RegisterNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}
