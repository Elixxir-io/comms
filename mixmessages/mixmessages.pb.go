// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mixmessages.proto

/*
Package mixmessages is a generated protocol buffer package.

It is generated from these files:
	mixmessages.proto

It has these top-level messages:
	Ack
	Ping
	Pong
	TimePing
	ServerMetricsMessage
	InitRound
	InitRoundAck
	CmixMessage
	ClientPollMessage
	ClientMessages
	ContactPoll
	UpsertUserMessage
	Contact
	ContactMessage
	PrecompDecryptSlot
	PrecompDecryptMessage
	PrecompEncryptSlot
	PrecompEncryptMessage
	PrecompRevealSlot
	PrecompRevealMessage
	PrecompPermuteSlot
	PrecompPermuteMessage
	PrecompShareInitMessage
	PrecompShareCompareMessage
	PrecompShareConfirmMessage
	PrecompShareSlot
	PrecompShareMessage
	RealtimeDecryptSlot
	RealtimeDecryptMessage
	RealtimeEncryptSlot
	RealtimeEncryptMessage
	RealtimePermuteSlot
	RealtimePermuteMessage
	PublicKeyMessage
	ErrorMessage
	ErrorAck
	InputMessages
	OutputMessages
*/
package mixmessages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Generic empty Ack message
type Ack struct {
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The request message asking if server is online
type Ping struct {
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The response message containing the online confirmation
type Pong struct {
}

func (m *Pong) Reset()                    { *m = Pong{} }
func (m *Pong) String() string            { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()               {}
func (*Pong) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// The request message asking server to add their time
type TimePing struct {
	Times []int64 `protobuf:"varint,1,rep,packed,name=Times" json:"Times,omitempty"`
}

func (m *TimePing) Reset()                    { *m = TimePing{} }
func (m *TimePing) String() string            { return proto.CompactTextString(m) }
func (*TimePing) ProtoMessage()               {}
func (*TimePing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TimePing) GetTimes() []int64 {
	if m != nil {
		return m.Times
	}
	return nil
}

// The message containing the server metrics from all visited nodes
type ServerMetricsMessage struct {
	MemUsage    []uint32 `protobuf:"varint,1,rep,packed,name=MemUsage" json:"MemUsage,omitempty"`
	ThreadUsage []uint32 `protobuf:"varint,2,rep,packed,name=ThreadUsage" json:"ThreadUsage,omitempty"`
	CpuUsage    []uint32 `protobuf:"varint,3,rep,packed,name=CpuUsage" json:"CpuUsage,omitempty"`
	UpSince     []uint64 `protobuf:"varint,4,rep,packed,name=UpSince" json:"UpSince,omitempty"`
}

func (m *ServerMetricsMessage) Reset()                    { *m = ServerMetricsMessage{} }
func (m *ServerMetricsMessage) String() string            { return proto.CompactTextString(m) }
func (*ServerMetricsMessage) ProtoMessage()               {}
func (*ServerMetricsMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ServerMetricsMessage) GetMemUsage() []uint32 {
	if m != nil {
		return m.MemUsage
	}
	return nil
}

func (m *ServerMetricsMessage) GetThreadUsage() []uint32 {
	if m != nil {
		return m.ThreadUsage
	}
	return nil
}

func (m *ServerMetricsMessage) GetCpuUsage() []uint32 {
	if m != nil {
		return m.CpuUsage
	}
	return nil
}

func (m *ServerMetricsMessage) GetUpSince() []uint64 {
	if m != nil {
		return m.UpSince
	}
	return nil
}

// The message for Init Round
type InitRound struct {
	RoundID string `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
}

func (m *InitRound) Reset()                    { *m = InitRound{} }
func (m *InitRound) String() string            { return proto.CompactTextString(m) }
func (*InitRound) ProtoMessage()               {}
func (*InitRound) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *InitRound) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

// The response for Init Round
type InitRoundAck struct {
}

func (m *InitRoundAck) Reset()                    { *m = InitRoundAck{} }
func (m *InitRoundAck) String() string            { return proto.CompactTextString(m) }
func (*InitRoundAck) ProtoMessage()               {}
func (*InitRoundAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// The standard CMIX message type
type CmixMessage struct {
	SenderID       uint64 `protobuf:"fixed64,1,opt,name=SenderID" json:"SenderID,omitempty"`
	MessagePayload []byte `protobuf:"bytes,2,opt,name=MessagePayload,proto3" json:"MessagePayload,omitempty"`
	RecipientID    []byte `protobuf:"bytes,3,opt,name=RecipientID,proto3" json:"RecipientID,omitempty"`
}

func (m *CmixMessage) Reset()                    { *m = CmixMessage{} }
func (m *CmixMessage) String() string            { return proto.CompactTextString(m) }
func (*CmixMessage) ProtoMessage()               {}
func (*CmixMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CmixMessage) GetSenderID() uint64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *CmixMessage) GetMessagePayload() []byte {
	if m != nil {
		return m.MessagePayload
	}
	return nil
}

func (m *CmixMessage) GetRecipientID() []byte {
	if m != nil {
		return m.RecipientID
	}
	return nil
}

// The message for clients to poll new CMIX messages
type ClientPollMessage struct {
	UserID    uint64 `protobuf:"fixed64,1,opt,name=UserID" json:"UserID,omitempty"`
	MessageID string `protobuf:"bytes,2,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *ClientPollMessage) Reset()                    { *m = ClientPollMessage{} }
func (m *ClientPollMessage) String() string            { return proto.CompactTextString(m) }
func (*ClientPollMessage) ProtoMessage()               {}
func (*ClientPollMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ClientPollMessage) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ClientPollMessage) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

// The message for clients to poll the gateway for Message IDs
type ClientMessages struct {
	MessageIDs []string `protobuf:"bytes,1,rep,name=MessageIDs" json:"MessageIDs,omitempty"`
}

func (m *ClientMessages) Reset()                    { *m = ClientMessages{} }
func (m *ClientMessages) String() string            { return proto.CompactTextString(m) }
func (*ClientMessages) ProtoMessage()               {}
func (*ClientMessages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ClientMessages) GetMessageIDs() []string {
	if m != nil {
		return m.MessageIDs
	}
	return nil
}

// Message for polling for the contact list
type ContactPoll struct {
}

func (m *ContactPoll) Reset()                    { *m = ContactPoll{} }
func (m *ContactPoll) String() string            { return proto.CompactTextString(m) }
func (*ContactPoll) ProtoMessage()               {}
func (*ContactPoll) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// Message for broadcasting user information to all other nodes
type UpsertUserMessage struct {
	NodeID        uint64 `protobuf:"fixed64,1,opt,name=NodeID" json:"NodeID,omitempty"`
	UserID        []byte `protobuf:"bytes,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	UserPublicKey []byte `protobuf:"bytes,3,opt,name=UserPublicKey,proto3" json:"UserPublicKey,omitempty"`
	Nonce         []byte `protobuf:"bytes,4,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	DsaSignature  []byte `protobuf:"bytes,5,opt,name=DsaSignature,proto3" json:"DsaSignature,omitempty"`
}

func (m *UpsertUserMessage) Reset()                    { *m = UpsertUserMessage{} }
func (m *UpsertUserMessage) String() string            { return proto.CompactTextString(m) }
func (*UpsertUserMessage) ProtoMessage()               {}
func (*UpsertUserMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UpsertUserMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *UpsertUserMessage) GetUserID() []byte {
	if m != nil {
		return m.UserID
	}
	return nil
}

func (m *UpsertUserMessage) GetUserPublicKey() []byte {
	if m != nil {
		return m.UserPublicKey
	}
	return nil
}

func (m *UpsertUserMessage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *UpsertUserMessage) GetDsaSignature() []byte {
	if m != nil {
		return m.DsaSignature
	}
	return nil
}

// Message for individual contacts
type Contact struct {
	UserID uint64 `protobuf:"varint,1,opt,name=userID" json:"userID,omitempty"`
	Nick   string `protobuf:"bytes,2,opt,name=nick" json:"nick,omitempty"`
}

func (m *Contact) Reset()                    { *m = Contact{} }
func (m *Contact) String() string            { return proto.CompactTextString(m) }
func (*Contact) ProtoMessage()               {}
func (*Contact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Contact) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Contact) GetNick() string {
	if m != nil {
		return m.Nick
	}
	return ""
}

// Message for list of contacts
type ContactMessage struct {
	Contacts []*Contact `protobuf:"bytes,1,rep,name=Contacts" json:"Contacts,omitempty"`
}

func (m *ContactMessage) Reset()                    { *m = ContactMessage{} }
func (m *ContactMessage) String() string            { return proto.CompactTextString(m) }
func (*ContactMessage) ProtoMessage()               {}
func (*ContactMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ContactMessage) GetContacts() []*Contact {
	if m != nil {
		return m.Contacts
	}
	return nil
}

// Message for individual Precomp Decrypt Slot
type PrecompDecryptSlot struct {
	Slot                         uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessageKeys         []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	EncryptedRecipientIDKeys     []byte `protobuf:"bytes,3,opt,name=EncryptedRecipientIDKeys,proto3" json:"EncryptedRecipientIDKeys,omitempty"`
	PartialMessageCypherText     []byte `protobuf:"bytes,4,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialRecipientIDCypherText []byte `protobuf:"bytes,5,opt,name=PartialRecipientIDCypherText,proto3" json:"PartialRecipientIDCypherText,omitempty"`
}

func (m *PrecompDecryptSlot) Reset()                    { *m = PrecompDecryptSlot{} }
func (m *PrecompDecryptSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompDecryptSlot) ProtoMessage()               {}
func (*PrecompDecryptSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *PrecompDecryptSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompDecryptSlot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *PrecompDecryptSlot) GetEncryptedRecipientIDKeys() []byte {
	if m != nil {
		return m.EncryptedRecipientIDKeys
	}
	return nil
}

func (m *PrecompDecryptSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *PrecompDecryptSlot) GetPartialRecipientIDCypherText() []byte {
	if m != nil {
		return m.PartialRecipientIDCypherText
	}
	return nil
}

// Message for batch of Precomp Decrypt Slots
type PrecompDecryptMessage struct {
	RoundID string                `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                 `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompDecryptSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompDecryptMessage) Reset()                    { *m = PrecompDecryptMessage{} }
func (m *PrecompDecryptMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompDecryptMessage) ProtoMessage()               {}
func (*PrecompDecryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PrecompDecryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompDecryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompDecryptMessage) GetSlots() []*PrecompDecryptSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Precomp Encrypt Slot
type PrecompEncryptSlot struct {
	Slot                     uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessageKeys     []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	PartialMessageCypherText []byte `protobuf:"bytes,3,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
}

func (m *PrecompEncryptSlot) Reset()                    { *m = PrecompEncryptSlot{} }
func (m *PrecompEncryptSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompEncryptSlot) ProtoMessage()               {}
func (*PrecompEncryptSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PrecompEncryptSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompEncryptSlot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *PrecompEncryptSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

// Message for batch of Precomp Encrypt Slots
type PrecompEncryptMessage struct {
	RoundID string                `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                 `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompEncryptSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompEncryptMessage) Reset()                    { *m = PrecompEncryptMessage{} }
func (m *PrecompEncryptMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompEncryptMessage) ProtoMessage()               {}
func (*PrecompEncryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *PrecompEncryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompEncryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompEncryptMessage) GetSlots() []*PrecompEncryptSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Precomp Reveal Slot
type PrecompRevealSlot struct {
	Slot                       uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	PartialMessageCypherText   []byte `protobuf:"bytes,2,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialRecipientCypherText []byte `protobuf:"bytes,3,opt,name=PartialRecipientCypherText,proto3" json:"PartialRecipientCypherText,omitempty"`
}

func (m *PrecompRevealSlot) Reset()                    { *m = PrecompRevealSlot{} }
func (m *PrecompRevealSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompRevealSlot) ProtoMessage()               {}
func (*PrecompRevealSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *PrecompRevealSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompRevealSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *PrecompRevealSlot) GetPartialRecipientCypherText() []byte {
	if m != nil {
		return m.PartialRecipientCypherText
	}
	return nil
}

// Message for batch of Precomp Reveal Slots
type PrecompRevealMessage struct {
	RoundID string               `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompRevealSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompRevealMessage) Reset()                    { *m = PrecompRevealMessage{} }
func (m *PrecompRevealMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompRevealMessage) ProtoMessage()               {}
func (*PrecompRevealMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *PrecompRevealMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompRevealMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompRevealMessage) GetSlots() []*PrecompRevealSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Precomp Permute Slot
type PrecompPermuteSlot struct {
	Slot                         uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessageKeys         []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	EncryptedRecipientIDKeys     []byte `protobuf:"bytes,3,opt,name=EncryptedRecipientIDKeys,proto3" json:"EncryptedRecipientIDKeys,omitempty"`
	PartialMessageCypherText     []byte `protobuf:"bytes,4,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialRecipientIDCypherText []byte `protobuf:"bytes,5,opt,name=PartialRecipientIDCypherText,proto3" json:"PartialRecipientIDCypherText,omitempty"`
}

func (m *PrecompPermuteSlot) Reset()                    { *m = PrecompPermuteSlot{} }
func (m *PrecompPermuteSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompPermuteSlot) ProtoMessage()               {}
func (*PrecompPermuteSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PrecompPermuteSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompPermuteSlot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *PrecompPermuteSlot) GetEncryptedRecipientIDKeys() []byte {
	if m != nil {
		return m.EncryptedRecipientIDKeys
	}
	return nil
}

func (m *PrecompPermuteSlot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *PrecompPermuteSlot) GetPartialRecipientIDCypherText() []byte {
	if m != nil {
		return m.PartialRecipientIDCypherText
	}
	return nil
}

// Message for batch of Precomp Permute Slots
type PrecompPermuteMessage struct {
	RoundID string                `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                 `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompPermuteSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompPermuteMessage) Reset()                    { *m = PrecompPermuteMessage{} }
func (m *PrecompPermuteMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompPermuteMessage) ProtoMessage()               {}
func (*PrecompPermuteMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *PrecompPermuteMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompPermuteMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompPermuteMessage) GetSlots() []*PrecompPermuteSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message from last node to indicate share phase is beginning
type PrecompShareInitMessage struct {
	RoundID       string `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	NodeID        uint64 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	SignedRoundID []byte `protobuf:"bytes,3,opt,name=SignedRoundID,proto3" json:"SignedRoundID,omitempty"`
}

func (m *PrecompShareInitMessage) Reset()                    { *m = PrecompShareInitMessage{} }
func (m *PrecompShareInitMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareInitMessage) ProtoMessage()               {}
func (*PrecompShareInitMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *PrecompShareInitMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompShareInitMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PrecompShareInitMessage) GetSignedRoundID() []byte {
	if m != nil {
		return m.SignedRoundID
	}
	return nil
}

// Message from each node to every other node to compare results of share phase
type PrecompShareCompareMessage struct {
	RoundCypherKey  []byte `protobuf:"bytes,1,opt,name=RoundCypherKey,proto3" json:"RoundCypherKey,omitempty"`
	NodeID          uint64 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	SignedCypherKey []byte `protobuf:"bytes,3,opt,name=SignedCypherKey,proto3" json:"SignedCypherKey,omitempty"`
}

func (m *PrecompShareCompareMessage) Reset()                    { *m = PrecompShareCompareMessage{} }
func (m *PrecompShareCompareMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareCompareMessage) ProtoMessage()               {}
func (*PrecompShareCompareMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *PrecompShareCompareMessage) GetRoundCypherKey() []byte {
	if m != nil {
		return m.RoundCypherKey
	}
	return nil
}

func (m *PrecompShareCompareMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PrecompShareCompareMessage) GetSignedCypherKey() []byte {
	if m != nil {
		return m.SignedCypherKey
	}
	return nil
}

// Message from each node after it has confirmed the round cypher key
type PrecompShareConfirmMessage struct {
	HashedCypherKey     []byte `protobuf:"bytes,1,opt,name=HashedCypherKey,proto3" json:"HashedCypherKey,omitempty"`
	NodeID              uint64 `protobuf:"varint,2,opt,name=NodeID" json:"NodeID,omitempty"`
	ComparisonResult    []byte `protobuf:"bytes,3,opt,name=ComparisonResult,proto3" json:"ComparisonResult,omitempty"`
	SignedCypherConfirm []byte `protobuf:"bytes,4,opt,name=SignedCypherConfirm,proto3" json:"SignedCypherConfirm,omitempty"`
}

func (m *PrecompShareConfirmMessage) Reset()                    { *m = PrecompShareConfirmMessage{} }
func (m *PrecompShareConfirmMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareConfirmMessage) ProtoMessage()               {}
func (*PrecompShareConfirmMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *PrecompShareConfirmMessage) GetHashedCypherKey() []byte {
	if m != nil {
		return m.HashedCypherKey
	}
	return nil
}

func (m *PrecompShareConfirmMessage) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PrecompShareConfirmMessage) GetComparisonResult() []byte {
	if m != nil {
		return m.ComparisonResult
	}
	return nil
}

func (m *PrecompShareConfirmMessage) GetSignedCypherConfirm() []byte {
	if m != nil {
		return m.SignedCypherConfirm
	}
	return nil
}

// Message for individual Precomp Share Slot
type PrecompShareSlot struct {
	Slot                        uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	PartialRoundPublicCypherKey []byte `protobuf:"bytes,2,opt,name=PartialRoundPublicCypherKey,proto3" json:"PartialRoundPublicCypherKey,omitempty"`
}

func (m *PrecompShareSlot) Reset()                    { *m = PrecompShareSlot{} }
func (m *PrecompShareSlot) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareSlot) ProtoMessage()               {}
func (*PrecompShareSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *PrecompShareSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *PrecompShareSlot) GetPartialRoundPublicCypherKey() []byte {
	if m != nil {
		return m.PartialRoundPublicCypherKey
	}
	return nil
}

// Message for batch of Precomp Share Slots
type PrecompShareMessage struct {
	RoundID string              `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32               `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*PrecompShareSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *PrecompShareMessage) Reset()                    { *m = PrecompShareMessage{} }
func (m *PrecompShareMessage) String() string            { return proto.CompactTextString(m) }
func (*PrecompShareMessage) ProtoMessage()               {}
func (*PrecompShareMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *PrecompShareMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PrecompShareMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *PrecompShareMessage) GetSlots() []*PrecompShareSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Realtime Decrypt Slot
type RealtimeDecryptSlot struct {
	Slot                 uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	SenderID             uint64 `protobuf:"varint,2,opt,name=SenderID" json:"SenderID,omitempty"`
	EncryptedMessage     []byte `protobuf:"bytes,3,opt,name=EncryptedMessage,proto3" json:"EncryptedMessage,omitempty"`
	EncryptedRecipientID []byte `protobuf:"bytes,4,opt,name=EncryptedRecipientID,proto3" json:"EncryptedRecipientID,omitempty"`
}

func (m *RealtimeDecryptSlot) Reset()                    { *m = RealtimeDecryptSlot{} }
func (m *RealtimeDecryptSlot) String() string            { return proto.CompactTextString(m) }
func (*RealtimeDecryptSlot) ProtoMessage()               {}
func (*RealtimeDecryptSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *RealtimeDecryptSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *RealtimeDecryptSlot) GetSenderID() uint64 {
	if m != nil {
		return m.SenderID
	}
	return 0
}

func (m *RealtimeDecryptSlot) GetEncryptedMessage() []byte {
	if m != nil {
		return m.EncryptedMessage
	}
	return nil
}

func (m *RealtimeDecryptSlot) GetEncryptedRecipientID() []byte {
	if m != nil {
		return m.EncryptedRecipientID
	}
	return nil
}

// Message for batch of Realtime Decrypt Slots
type RealtimeDecryptMessage struct {
	RoundID string                 `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                  `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*RealtimeDecryptSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *RealtimeDecryptMessage) Reset()                    { *m = RealtimeDecryptMessage{} }
func (m *RealtimeDecryptMessage) String() string            { return proto.CompactTextString(m) }
func (*RealtimeDecryptMessage) ProtoMessage()               {}
func (*RealtimeDecryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *RealtimeDecryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *RealtimeDecryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *RealtimeDecryptMessage) GetSlots() []*RealtimeDecryptSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Realtime Encrypt Slot
type RealtimeEncryptSlot struct {
	Slot             uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	RecipientID      uint64 `protobuf:"varint,2,opt,name=RecipientID" json:"RecipientID,omitempty"`
	EncryptedMessage []byte `protobuf:"bytes,3,opt,name=EncryptedMessage,proto3" json:"EncryptedMessage,omitempty"`
}

func (m *RealtimeEncryptSlot) Reset()                    { *m = RealtimeEncryptSlot{} }
func (m *RealtimeEncryptSlot) String() string            { return proto.CompactTextString(m) }
func (*RealtimeEncryptSlot) ProtoMessage()               {}
func (*RealtimeEncryptSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *RealtimeEncryptSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *RealtimeEncryptSlot) GetRecipientID() uint64 {
	if m != nil {
		return m.RecipientID
	}
	return 0
}

func (m *RealtimeEncryptSlot) GetEncryptedMessage() []byte {
	if m != nil {
		return m.EncryptedMessage
	}
	return nil
}

// Message for batch of Realtime Encrypt Slots
type RealtimeEncryptMessage struct {
	RoundID string                 `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                  `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*RealtimeEncryptSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *RealtimeEncryptMessage) Reset()                    { *m = RealtimeEncryptMessage{} }
func (m *RealtimeEncryptMessage) String() string            { return proto.CompactTextString(m) }
func (*RealtimeEncryptMessage) ProtoMessage()               {}
func (*RealtimeEncryptMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *RealtimeEncryptMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *RealtimeEncryptMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *RealtimeEncryptMessage) GetSlots() []*RealtimeEncryptSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for individual Realtime Permute Slot
type RealtimePermuteSlot struct {
	Slot                 uint64 `protobuf:"varint,1,opt,name=Slot" json:"Slot,omitempty"`
	EncryptedMessage     []byte `protobuf:"bytes,2,opt,name=EncryptedMessage,proto3" json:"EncryptedMessage,omitempty"`
	EncryptedRecipientID []byte `protobuf:"bytes,3,opt,name=EncryptedRecipientID,proto3" json:"EncryptedRecipientID,omitempty"`
}

func (m *RealtimePermuteSlot) Reset()                    { *m = RealtimePermuteSlot{} }
func (m *RealtimePermuteSlot) String() string            { return proto.CompactTextString(m) }
func (*RealtimePermuteSlot) ProtoMessage()               {}
func (*RealtimePermuteSlot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *RealtimePermuteSlot) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *RealtimePermuteSlot) GetEncryptedMessage() []byte {
	if m != nil {
		return m.EncryptedMessage
	}
	return nil
}

func (m *RealtimePermuteSlot) GetEncryptedRecipientID() []byte {
	if m != nil {
		return m.EncryptedRecipientID
	}
	return nil
}

// Message for batch of Realtime Permute Slots
type RealtimePermuteMessage struct {
	RoundID string                 `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	LastOp  int32                  `protobuf:"varint,2,opt,name=LastOp" json:"LastOp,omitempty"`
	Slots   []*RealtimePermuteSlot `protobuf:"bytes,3,rep,name=Slots" json:"Slots,omitempty"`
}

func (m *RealtimePermuteMessage) Reset()                    { *m = RealtimePermuteMessage{} }
func (m *RealtimePermuteMessage) String() string            { return proto.CompactTextString(m) }
func (*RealtimePermuteMessage) ProtoMessage()               {}
func (*RealtimePermuteMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *RealtimePermuteMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *RealtimePermuteMessage) GetLastOp() int32 {
	if m != nil {
		return m.LastOp
	}
	return 0
}

func (m *RealtimePermuteMessage) GetSlots() []*RealtimePermuteSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Message for setting public key
type PublicKeyMessage struct {
	RoundID   string `protobuf:"bytes,1,opt,name=RoundID" json:"RoundID,omitempty"`
	PublicKey []byte `protobuf:"bytes,2,opt,name=PublicKey,proto3" json:"PublicKey,omitempty"`
}

func (m *PublicKeyMessage) Reset()                    { *m = PublicKeyMessage{} }
func (m *PublicKeyMessage) String() string            { return proto.CompactTextString(m) }
func (*PublicKeyMessage) ProtoMessage()               {}
func (*PublicKeyMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *PublicKeyMessage) GetRoundID() string {
	if m != nil {
		return m.RoundID
	}
	return ""
}

func (m *PublicKeyMessage) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// ErrorMessage encodes an error message
type ErrorMessage struct {
	Message string `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
}

func (m *ErrorMessage) Reset()                    { *m = ErrorMessage{} }
func (m *ErrorMessage) String() string            { return proto.CompactTextString(m) }
func (*ErrorMessage) ProtoMessage()               {}
func (*ErrorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *ErrorMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// ErrorAck returns the length of the received messages
type ErrorAck struct {
	MsgLen int32 `protobuf:"varint,1,opt,name=MsgLen" json:"MsgLen,omitempty"`
}

func (m *ErrorAck) Reset()                    { *m = ErrorAck{} }
func (m *ErrorAck) String() string            { return proto.CompactTextString(m) }
func (*ErrorAck) ProtoMessage()               {}
func (*ErrorAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *ErrorAck) GetMsgLen() int32 {
	if m != nil {
		return m.MsgLen
	}
	return 0
}

// Input messages are a list of messages run as a batch
type InputMessages struct {
	Messages []*CmixMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *InputMessages) Reset()                    { *m = InputMessages{} }
func (m *InputMessages) String() string            { return proto.CompactTextString(m) }
func (*InputMessages) ProtoMessage()               {}
func (*InputMessages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *InputMessages) GetMessages() []*CmixMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

// Output messages are a list of messages run as a batch
type OutputMessages struct {
	Messages []*CmixMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *OutputMessages) Reset()                    { *m = OutputMessages{} }
func (m *OutputMessages) String() string            { return proto.CompactTextString(m) }
func (*OutputMessages) ProtoMessage()               {}
func (*OutputMessages) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *OutputMessages) GetMessages() []*CmixMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

func init() {
	proto.RegisterType((*Ack)(nil), "mixmessages.Ack")
	proto.RegisterType((*Ping)(nil), "mixmessages.Ping")
	proto.RegisterType((*Pong)(nil), "mixmessages.Pong")
	proto.RegisterType((*TimePing)(nil), "mixmessages.TimePing")
	proto.RegisterType((*ServerMetricsMessage)(nil), "mixmessages.ServerMetricsMessage")
	proto.RegisterType((*InitRound)(nil), "mixmessages.InitRound")
	proto.RegisterType((*InitRoundAck)(nil), "mixmessages.InitRoundAck")
	proto.RegisterType((*CmixMessage)(nil), "mixmessages.CmixMessage")
	proto.RegisterType((*ClientPollMessage)(nil), "mixmessages.ClientPollMessage")
	proto.RegisterType((*ClientMessages)(nil), "mixmessages.ClientMessages")
	proto.RegisterType((*ContactPoll)(nil), "mixmessages.ContactPoll")
	proto.RegisterType((*UpsertUserMessage)(nil), "mixmessages.UpsertUserMessage")
	proto.RegisterType((*Contact)(nil), "mixmessages.Contact")
	proto.RegisterType((*ContactMessage)(nil), "mixmessages.ContactMessage")
	proto.RegisterType((*PrecompDecryptSlot)(nil), "mixmessages.PrecompDecryptSlot")
	proto.RegisterType((*PrecompDecryptMessage)(nil), "mixmessages.PrecompDecryptMessage")
	proto.RegisterType((*PrecompEncryptSlot)(nil), "mixmessages.PrecompEncryptSlot")
	proto.RegisterType((*PrecompEncryptMessage)(nil), "mixmessages.PrecompEncryptMessage")
	proto.RegisterType((*PrecompRevealSlot)(nil), "mixmessages.PrecompRevealSlot")
	proto.RegisterType((*PrecompRevealMessage)(nil), "mixmessages.PrecompRevealMessage")
	proto.RegisterType((*PrecompPermuteSlot)(nil), "mixmessages.PrecompPermuteSlot")
	proto.RegisterType((*PrecompPermuteMessage)(nil), "mixmessages.PrecompPermuteMessage")
	proto.RegisterType((*PrecompShareInitMessage)(nil), "mixmessages.PrecompShareInitMessage")
	proto.RegisterType((*PrecompShareCompareMessage)(nil), "mixmessages.PrecompShareCompareMessage")
	proto.RegisterType((*PrecompShareConfirmMessage)(nil), "mixmessages.PrecompShareConfirmMessage")
	proto.RegisterType((*PrecompShareSlot)(nil), "mixmessages.PrecompShareSlot")
	proto.RegisterType((*PrecompShareMessage)(nil), "mixmessages.PrecompShareMessage")
	proto.RegisterType((*RealtimeDecryptSlot)(nil), "mixmessages.RealtimeDecryptSlot")
	proto.RegisterType((*RealtimeDecryptMessage)(nil), "mixmessages.RealtimeDecryptMessage")
	proto.RegisterType((*RealtimeEncryptSlot)(nil), "mixmessages.RealtimeEncryptSlot")
	proto.RegisterType((*RealtimeEncryptMessage)(nil), "mixmessages.RealtimeEncryptMessage")
	proto.RegisterType((*RealtimePermuteSlot)(nil), "mixmessages.RealtimePermuteSlot")
	proto.RegisterType((*RealtimePermuteMessage)(nil), "mixmessages.RealtimePermuteMessage")
	proto.RegisterType((*PublicKeyMessage)(nil), "mixmessages.PublicKeyMessage")
	proto.RegisterType((*ErrorMessage)(nil), "mixmessages.ErrorMessage")
	proto.RegisterType((*ErrorAck)(nil), "mixmessages.ErrorAck")
	proto.RegisterType((*InputMessages)(nil), "mixmessages.InputMessages")
	proto.RegisterType((*OutputMessages)(nil), "mixmessages.OutputMessages")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MixMessageNode service

type MixMessageNodeClient interface {
	// Handles ErrorMessage
	NetworkError(ctx context.Context, in *ErrorMessage, opts ...grpc.CallOption) (*ErrorAck, error)
	// Handles AskOnline
	AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Pong, error)
	// Handles RoundtripPing
	RoundtripPing(ctx context.Context, in *TimePing, opts ...grpc.CallOption) (*Ack, error)
	// Handles ServerMetrics
	ServerMetrics(ctx context.Context, in *ServerMetricsMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Init Round
	NewRound(ctx context.Context, in *InitRound, opts ...grpc.CallOption) (*InitRoundAck, error)
	// Handles Precomp Decrypt
	PrecompDecrypt(ctx context.Context, in *PrecompDecryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Encrypt
	PrecompEncrypt(ctx context.Context, in *PrecompEncryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Reveal
	PrecompReveal(ctx context.Context, in *PrecompRevealMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Permute
	PrecompPermute(ctx context.Context, in *PrecompPermuteMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share
	PrecompShare(ctx context.Context, in *PrecompShareMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share Initialization
	PrecompShareInit(ctx context.Context, in *PrecompShareInitMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share Comparison
	PrecompShareCompare(ctx context.Context, in *PrecompShareCompareMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Precomp Share Confirmation
	PrecompShareConfirm(ctx context.Context, in *PrecompShareConfirmMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Realtime Decrypt
	RealtimeDecrypt(ctx context.Context, in *RealtimeDecryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Realtime Encrypt
	RealtimeEncrypt(ctx context.Context, in *RealtimeEncryptMessage, opts ...grpc.CallOption) (*Ack, error)
	// Handles Realtime Permute
	RealtimePermute(ctx context.Context, in *RealtimePermuteMessage, opts ...grpc.CallOption) (*Ack, error)
	// Set the public key
	SetPublicKey(ctx context.Context, in *PublicKeyMessage, opts ...grpc.CallOption) (*Ack, error)
	// Send CmixMessage from Client to Server
	ClientSendMessageToServer(ctx context.Context, in *CmixMessage, opts ...grpc.CallOption) (*Ack, error)
	// Request a CmixMessage from the server for the given User
	ClientPoll(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*CmixMessage, error)
	// Request a list of contacts from the server
	RequestContactList(ctx context.Context, in *ContactPoll, opts ...grpc.CallOption) (*ContactMessage, error)
	// Set a single user's nick on the server
	SetNick(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Ack, error)
	// Broadcasts user information to all other nodes
	UserUpsert(ctx context.Context, in *UpsertUserMessage, opts ...grpc.CallOption) (*Ack, error)
	// Starts a new round with these messages (if len(msgs) == batch size)
	StartRound(ctx context.Context, in *InputMessages, opts ...grpc.CallOption) (*Ack, error)
}

type mixMessageNodeClient struct {
	cc *grpc.ClientConn
}

func NewMixMessageNodeClient(cc *grpc.ClientConn) MixMessageNodeClient {
	return &mixMessageNodeClient{cc}
}

func (c *mixMessageNodeClient) NetworkError(ctx context.Context, in *ErrorMessage, opts ...grpc.CallOption) (*ErrorAck, error) {
	out := new(ErrorAck)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/NetworkError", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Pong, error) {
	out := new(Pong)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/AskOnline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RoundtripPing(ctx context.Context, in *TimePing, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RoundtripPing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) ServerMetrics(ctx context.Context, in *ServerMetricsMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/ServerMetrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) NewRound(ctx context.Context, in *InitRound, opts ...grpc.CallOption) (*InitRoundAck, error) {
	out := new(InitRoundAck)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/NewRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompDecrypt(ctx context.Context, in *PrecompDecryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompDecrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompEncrypt(ctx context.Context, in *PrecompEncryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompEncrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompReveal(ctx context.Context, in *PrecompRevealMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompReveal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompPermute(ctx context.Context, in *PrecompPermuteMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompPermute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShare(ctx context.Context, in *PrecompShareMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShareInit(ctx context.Context, in *PrecompShareInitMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShareInit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShareCompare(ctx context.Context, in *PrecompShareCompareMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShareCompare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) PrecompShareConfirm(ctx context.Context, in *PrecompShareConfirmMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/PrecompShareConfirm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RealtimeDecrypt(ctx context.Context, in *RealtimeDecryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RealtimeDecrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RealtimeEncrypt(ctx context.Context, in *RealtimeEncryptMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RealtimeEncrypt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RealtimePermute(ctx context.Context, in *RealtimePermuteMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RealtimePermute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) SetPublicKey(ctx context.Context, in *PublicKeyMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/SetPublicKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) ClientSendMessageToServer(ctx context.Context, in *CmixMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/ClientSendMessageToServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) ClientPoll(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*CmixMessage, error) {
	out := new(CmixMessage)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/ClientPoll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) RequestContactList(ctx context.Context, in *ContactPoll, opts ...grpc.CallOption) (*ContactMessage, error) {
	out := new(ContactMessage)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/RequestContactList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) SetNick(ctx context.Context, in *Contact, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/SetNick", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) UserUpsert(ctx context.Context, in *UpsertUserMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/UserUpsert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageNodeClient) StartRound(ctx context.Context, in *InputMessages, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageNode/StartRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MixMessageNode service

type MixMessageNodeServer interface {
	// Handles ErrorMessage
	NetworkError(context.Context, *ErrorMessage) (*ErrorAck, error)
	// Handles AskOnline
	AskOnline(context.Context, *Ping) (*Pong, error)
	// Handles RoundtripPing
	RoundtripPing(context.Context, *TimePing) (*Ack, error)
	// Handles ServerMetrics
	ServerMetrics(context.Context, *ServerMetricsMessage) (*Ack, error)
	// Handles Init Round
	NewRound(context.Context, *InitRound) (*InitRoundAck, error)
	// Handles Precomp Decrypt
	PrecompDecrypt(context.Context, *PrecompDecryptMessage) (*Ack, error)
	// Handles Precomp Encrypt
	PrecompEncrypt(context.Context, *PrecompEncryptMessage) (*Ack, error)
	// Handles Precomp Reveal
	PrecompReveal(context.Context, *PrecompRevealMessage) (*Ack, error)
	// Handles Precomp Permute
	PrecompPermute(context.Context, *PrecompPermuteMessage) (*Ack, error)
	// Handles Precomp Share
	PrecompShare(context.Context, *PrecompShareMessage) (*Ack, error)
	// Handles Precomp Share Initialization
	PrecompShareInit(context.Context, *PrecompShareInitMessage) (*Ack, error)
	// Handles Precomp Share Comparison
	PrecompShareCompare(context.Context, *PrecompShareCompareMessage) (*Ack, error)
	// Handles Precomp Share Confirmation
	PrecompShareConfirm(context.Context, *PrecompShareConfirmMessage) (*Ack, error)
	// Handles Realtime Decrypt
	RealtimeDecrypt(context.Context, *RealtimeDecryptMessage) (*Ack, error)
	// Handles Realtime Encrypt
	RealtimeEncrypt(context.Context, *RealtimeEncryptMessage) (*Ack, error)
	// Handles Realtime Permute
	RealtimePermute(context.Context, *RealtimePermuteMessage) (*Ack, error)
	// Set the public key
	SetPublicKey(context.Context, *PublicKeyMessage) (*Ack, error)
	// Send CmixMessage from Client to Server
	ClientSendMessageToServer(context.Context, *CmixMessage) (*Ack, error)
	// Request a CmixMessage from the server for the given User
	ClientPoll(context.Context, *ClientPollMessage) (*CmixMessage, error)
	// Request a list of contacts from the server
	RequestContactList(context.Context, *ContactPoll) (*ContactMessage, error)
	// Set a single user's nick on the server
	SetNick(context.Context, *Contact) (*Ack, error)
	// Broadcasts user information to all other nodes
	UserUpsert(context.Context, *UpsertUserMessage) (*Ack, error)
	// Starts a new round with these messages (if len(msgs) == batch size)
	StartRound(context.Context, *InputMessages) (*Ack, error)
}

func RegisterMixMessageNodeServer(s *grpc.Server, srv MixMessageNodeServer) {
	s.RegisterService(&_MixMessageNode_serviceDesc, srv)
}

func _MixMessageNode_NetworkError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).NetworkError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/NetworkError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).NetworkError(ctx, req.(*ErrorMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_AskOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).AskOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/AskOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).AskOnline(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RoundtripPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimePing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RoundtripPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RoundtripPing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RoundtripPing(ctx, req.(*TimePing))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_ServerMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerMetricsMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).ServerMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/ServerMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).ServerMetrics(ctx, req.(*ServerMetricsMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_NewRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitRound)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).NewRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/NewRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).NewRound(ctx, req.(*InitRound))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompDecryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompDecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompDecrypt(ctx, req.(*PrecompDecryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompEncryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompEncrypt(ctx, req.(*PrecompEncryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompReveal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompRevealMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompReveal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompReveal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompReveal(ctx, req.(*PrecompRevealMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompPermute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompPermuteMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompPermute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompPermute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompPermute(ctx, req.(*PrecompPermuteMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShare(ctx, req.(*PrecompShareMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShareInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareInitMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShareInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShareInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShareInit(ctx, req.(*PrecompShareInitMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShareCompare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareCompareMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShareCompare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShareCompare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShareCompare(ctx, req.(*PrecompShareCompareMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_PrecompShareConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrecompShareConfirmMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).PrecompShareConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/PrecompShareConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).PrecompShareConfirm(ctx, req.(*PrecompShareConfirmMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RealtimeDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeDecryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RealtimeDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RealtimeDecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RealtimeDecrypt(ctx, req.(*RealtimeDecryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RealtimeEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimeEncryptMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RealtimeEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RealtimeEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RealtimeEncrypt(ctx, req.(*RealtimeEncryptMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RealtimePermute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RealtimePermuteMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RealtimePermute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RealtimePermute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RealtimePermute(ctx, req.(*RealtimePermuteMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_SetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicKeyMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).SetPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/SetPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).SetPublicKey(ctx, req.(*PublicKeyMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_ClientSendMessageToServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmixMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).ClientSendMessageToServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/ClientSendMessageToServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).ClientSendMessageToServer(ctx, req.(*CmixMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_ClientPoll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientPollMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).ClientPoll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/ClientPoll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).ClientPoll(ctx, req.(*ClientPollMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_RequestContactList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContactPoll)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).RequestContactList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/RequestContactList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).RequestContactList(ctx, req.(*ContactPoll))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_SetNick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Contact)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).SetNick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/SetNick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).SetNick(ctx, req.(*Contact))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_UserUpsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertUserMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).UserUpsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/UserUpsert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).UserUpsert(ctx, req.(*UpsertUserMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageNode_StartRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageNodeServer).StartRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageNode/StartRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageNodeServer).StartRound(ctx, req.(*InputMessages))
	}
	return interceptor(ctx, in, info, handler)
}

var _MixMessageNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.MixMessageNode",
	HandlerType: (*MixMessageNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NetworkError",
			Handler:    _MixMessageNode_NetworkError_Handler,
		},
		{
			MethodName: "AskOnline",
			Handler:    _MixMessageNode_AskOnline_Handler,
		},
		{
			MethodName: "RoundtripPing",
			Handler:    _MixMessageNode_RoundtripPing_Handler,
		},
		{
			MethodName: "ServerMetrics",
			Handler:    _MixMessageNode_ServerMetrics_Handler,
		},
		{
			MethodName: "NewRound",
			Handler:    _MixMessageNode_NewRound_Handler,
		},
		{
			MethodName: "PrecompDecrypt",
			Handler:    _MixMessageNode_PrecompDecrypt_Handler,
		},
		{
			MethodName: "PrecompEncrypt",
			Handler:    _MixMessageNode_PrecompEncrypt_Handler,
		},
		{
			MethodName: "PrecompReveal",
			Handler:    _MixMessageNode_PrecompReveal_Handler,
		},
		{
			MethodName: "PrecompPermute",
			Handler:    _MixMessageNode_PrecompPermute_Handler,
		},
		{
			MethodName: "PrecompShare",
			Handler:    _MixMessageNode_PrecompShare_Handler,
		},
		{
			MethodName: "PrecompShareInit",
			Handler:    _MixMessageNode_PrecompShareInit_Handler,
		},
		{
			MethodName: "PrecompShareCompare",
			Handler:    _MixMessageNode_PrecompShareCompare_Handler,
		},
		{
			MethodName: "PrecompShareConfirm",
			Handler:    _MixMessageNode_PrecompShareConfirm_Handler,
		},
		{
			MethodName: "RealtimeDecrypt",
			Handler:    _MixMessageNode_RealtimeDecrypt_Handler,
		},
		{
			MethodName: "RealtimeEncrypt",
			Handler:    _MixMessageNode_RealtimeEncrypt_Handler,
		},
		{
			MethodName: "RealtimePermute",
			Handler:    _MixMessageNode_RealtimePermute_Handler,
		},
		{
			MethodName: "SetPublicKey",
			Handler:    _MixMessageNode_SetPublicKey_Handler,
		},
		{
			MethodName: "ClientSendMessageToServer",
			Handler:    _MixMessageNode_ClientSendMessageToServer_Handler,
		},
		{
			MethodName: "ClientPoll",
			Handler:    _MixMessageNode_ClientPoll_Handler,
		},
		{
			MethodName: "RequestContactList",
			Handler:    _MixMessageNode_RequestContactList_Handler,
		},
		{
			MethodName: "SetNick",
			Handler:    _MixMessageNode_SetNick_Handler,
		},
		{
			MethodName: "UserUpsert",
			Handler:    _MixMessageNode_UserUpsert_Handler,
		},
		{
			MethodName: "StartRound",
			Handler:    _MixMessageNode_StartRound_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// Client API for MixMessageGateway service

type MixMessageGatewayClient interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*ClientMessages, error)
	// Request a CmixMessage from the gateway for the given message information
	GetMessage(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*CmixMessage, error)
	// Put a message on the cMix Gateway
	PutMessage(ctx context.Context, in *CmixMessage, opts ...grpc.CallOption) (*Ack, error)
	ReceiveBatch(ctx context.Context, in *OutputMessages, opts ...grpc.CallOption) (*Ack, error)
}

type mixMessageGatewayClient struct {
	cc *grpc.ClientConn
}

func NewMixMessageGatewayClient(cc *grpc.ClientConn) MixMessageGatewayClient {
	return &mixMessageGatewayClient{cc}
}

func (c *mixMessageGatewayClient) CheckMessages(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*ClientMessages, error) {
	out := new(ClientMessages)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/CheckMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) GetMessage(ctx context.Context, in *ClientPollMessage, opts ...grpc.CallOption) (*CmixMessage, error) {
	out := new(CmixMessage)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/GetMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) PutMessage(ctx context.Context, in *CmixMessage, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/PutMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mixMessageGatewayClient) ReceiveBatch(ctx context.Context, in *OutputMessages, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.MixMessageGateway/ReceiveBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MixMessageGateway service

type MixMessageGatewayServer interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(context.Context, *ClientPollMessage) (*ClientMessages, error)
	// Request a CmixMessage from the gateway for the given message information
	GetMessage(context.Context, *ClientPollMessage) (*CmixMessage, error)
	// Put a message on the cMix Gateway
	PutMessage(context.Context, *CmixMessage) (*Ack, error)
	ReceiveBatch(context.Context, *OutputMessages) (*Ack, error)
}

func RegisterMixMessageGatewayServer(s *grpc.Server, srv MixMessageGatewayServer) {
	s.RegisterService(&_MixMessageGateway_serviceDesc, srv)
}

func _MixMessageGateway_CheckMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientPollMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).CheckMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/CheckMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).CheckMessages(ctx, req.(*ClientPollMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientPollMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/GetMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).GetMessage(ctx, req.(*ClientPollMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmixMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/PutMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).PutMessage(ctx, req.(*CmixMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MixMessageGateway_ReceiveBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutputMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MixMessageGatewayServer).ReceiveBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.MixMessageGateway/ReceiveBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MixMessageGatewayServer).ReceiveBatch(ctx, req.(*OutputMessages))
	}
	return interceptor(ctx, in, info, handler)
}

var _MixMessageGateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.MixMessageGateway",
	HandlerType: (*MixMessageGatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckMessages",
			Handler:    _MixMessageGateway_CheckMessages_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _MixMessageGateway_GetMessage_Handler,
		},
		{
			MethodName: "PutMessage",
			Handler:    _MixMessageGateway_PutMessage_Handler,
		},
		{
			MethodName: "ReceiveBatch",
			Handler:    _MixMessageGateway_ReceiveBatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

func init() { proto.RegisterFile("mixmessages.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1483 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcf, 0x72, 0xdb, 0x36,
	0x13, 0x8f, 0x24, 0xdb, 0xb1, 0xd6, 0x92, 0x62, 0x23, 0x4e, 0x3e, 0x45, 0xc9, 0x97, 0xaa, 0x48,
	0x9a, 0x6a, 0x72, 0xc8, 0x64, 0xec, 0xa4, 0x87, 0x4c, 0xa7, 0x89, 0x2d, 0xe7, 0x8f, 0x12, 0xdb,
	0xd1, 0x50, 0xf6, 0x03, 0x30, 0x14, 0x2a, 0x71, 0x24, 0x91, 0x0c, 0x09, 0xc5, 0xd1, 0x4c, 0xa7,
	0xd3, 0xe9, 0xa1, 0x33, 0xed, 0x13, 0xe4, 0xde, 0xe9, 0xa5, 0xcf, 0xd0, 0x87, 0xea, 0x23, 0x74,
	0x40, 0x80, 0x24, 0x40, 0x81, 0x94, 0x12, 0x37, 0xb7, 0x9e, 0x48, 0xec, 0x2e, 0x16, 0xbb, 0x3f,
	0x2c, 0xb0, 0x8b, 0x85, 0xad, 0x89, 0xfd, 0x7e, 0x42, 0x82, 0xc0, 0x1c, 0x90, 0xe0, 0x9e, 0xe7,
	0xbb, 0xd4, 0x45, 0x1b, 0x12, 0x09, 0xaf, 0x42, 0x69, 0xcf, 0x1a, 0xe1, 0x35, 0x58, 0xe9, 0xda,
	0xce, 0x20, 0xfc, 0xba, 0xce, 0x00, 0x37, 0x61, 0xfd, 0xc4, 0x9e, 0x10, 0x46, 0x43, 0xdb, 0xb0,
	0xca, 0xfe, 0x83, 0x7a, 0xa1, 0x59, 0x6a, 0x95, 0x0c, 0x3e, 0xc0, 0xbf, 0x15, 0x60, 0xbb, 0x47,
	0xfc, 0x77, 0xc4, 0x3f, 0x22, 0xd4, 0xb7, 0xad, 0xe0, 0x88, 0xab, 0x44, 0x0d, 0x58, 0x3f, 0x22,
	0x93, 0x53, 0xf6, 0x1f, 0xce, 0xa8, 0x1a, 0xf1, 0x18, 0x35, 0x61, 0xe3, 0x64, 0xe8, 0x13, 0xb3,
	0xcf, 0xd9, 0xc5, 0x90, 0x2d, 0x93, 0xd8, 0xec, 0xb6, 0x37, 0xe5, 0xec, 0x12, 0x9f, 0x1d, 0x8d,
	0x51, 0x1d, 0x2e, 0x9e, 0x7a, 0x3d, 0xdb, 0xb1, 0x48, 0x7d, 0xa5, 0x59, 0x6a, 0xad, 0x18, 0xd1,
	0x10, 0x7f, 0x05, 0xe5, 0x8e, 0x63, 0x53, 0xc3, 0x9d, 0x3a, 0x7d, 0x26, 0x16, 0xfe, 0x74, 0x0e,
	0xea, 0x85, 0x66, 0xa1, 0x55, 0x36, 0xa2, 0x21, 0xae, 0x41, 0x25, 0x16, 0x63, 0x5e, 0x07, 0xb0,
	0xd1, 0x9e, 0xd8, 0xef, 0x25, 0xcb, 0x7b, 0xc4, 0xe9, 0x13, 0x5f, 0xcc, 0x5c, 0x33, 0xe2, 0x31,
	0xba, 0x03, 0x35, 0x21, 0xd6, 0x35, 0x67, 0x63, 0xd7, 0xec, 0xd7, 0x8b, 0xcd, 0x42, 0xab, 0x62,
	0xa4, 0xa8, 0xcc, 0x43, 0x83, 0x58, 0xb6, 0x67, 0x13, 0x87, 0x76, 0x0e, 0xea, 0xa5, 0x50, 0x48,
	0x26, 0xe1, 0x0e, 0x6c, 0xb5, 0xc7, 0xec, 0xbf, 0xeb, 0x8e, 0xc7, 0xd1, 0xd2, 0x57, 0x61, 0xed,
	0x34, 0x90, 0x16, 0x16, 0x23, 0x74, 0x03, 0xca, 0x42, 0xa4, 0x73, 0x10, 0xae, 0x58, 0x36, 0x12,
	0x02, 0xbe, 0x0f, 0x35, 0xae, 0x4a, 0x90, 0x02, 0x74, 0x13, 0x20, 0x66, 0xf3, 0x0d, 0x2b, 0x1b,
	0x12, 0x05, 0x57, 0x61, 0xa3, 0xed, 0x3a, 0xd4, 0xb4, 0xc2, 0xd5, 0xf1, 0xef, 0x05, 0xd8, 0x3a,
	0xf5, 0x02, 0xe2, 0x53, 0xb6, 0x9e, 0x64, 0xcc, 0xb1, 0xdb, 0x27, 0x89, 0x31, 0x7c, 0x24, 0x19,
	0xc9, 0x7d, 0x8f, 0x8c, 0xbc, 0x0d, 0x55, 0xf6, 0xd7, 0x9d, 0xbe, 0x19, 0xdb, 0xd6, 0x2b, 0x32,
	0x13, 0x5e, 0xab, 0x44, 0x16, 0x46, 0xc7, 0x2e, 0xdf, 0x3b, 0xc6, 0xe5, 0x03, 0x84, 0xa1, 0x72,
	0x10, 0x98, 0x3d, 0x7b, 0xe0, 0x98, 0x74, 0xea, 0x93, 0xfa, 0x6a, 0xc8, 0x54, 0x68, 0xf8, 0x21,
	0x5c, 0x14, 0x46, 0x33, 0x13, 0xa6, 0x09, 0x4e, 0x2b, 0x86, 0x18, 0x21, 0x04, 0x2b, 0x8e, 0x6d,
	0x8d, 0x04, 0x44, 0xe1, 0x3f, 0xde, 0x87, 0x9a, 0x98, 0x16, 0x39, 0x76, 0x1f, 0xd6, 0x05, 0x85,
	0x63, 0xb3, 0xb1, 0xb3, 0x7d, 0x4f, 0x3e, 0x1f, 0x82, 0x69, 0xc4, 0x52, 0xf8, 0x43, 0x11, 0x50,
	0xd7, 0x27, 0x96, 0x3b, 0xf1, 0x0e, 0x88, 0xe5, 0xcf, 0x3c, 0xda, 0x1b, 0xbb, 0x94, 0x2d, 0xc7,
	0xbe, 0xc2, 0x88, 0xf0, 0x1f, 0xed, 0xc0, 0xf6, 0x53, 0x27, 0x14, 0x21, 0x7d, 0xb1, 0xe0, 0x2b,
	0x32, 0x0b, 0x04, 0x56, 0x5a, 0x1e, 0x7a, 0x04, 0xf5, 0x98, 0x2e, 0xc5, 0x48, 0x38, 0x8f, 0x83,
	0x98, 0xc9, 0x67, 0x73, 0xbb, 0xa6, 0x4f, 0x6d, 0x33, 0x0a, 0xa2, 0xf6, 0xcc, 0x1b, 0x12, 0xff,
	0x84, 0xbc, 0xa7, 0x02, 0xe2, 0x4c, 0x3e, 0xda, 0x87, 0x1b, 0x82, 0x27, 0x69, 0x95, 0xe6, 0xf3,
	0x5d, 0xc8, 0x95, 0xc1, 0x3f, 0x15, 0xe0, 0x8a, 0x0a, 0x4d, 0x04, 0x73, 0xe6, 0x01, 0x64, 0xdb,
	0x77, 0x68, 0x06, 0xf4, 0xb5, 0x17, 0xa2, 0xb2, 0x6a, 0x88, 0x11, 0x7a, 0x08, 0xab, 0x0c, 0xc3,
	0x20, 0x3c, 0xf2, 0x1b, 0x3b, 0x5f, 0x28, 0xbb, 0x32, 0x8f, 0xbf, 0xc1, 0xa5, 0xf1, 0x87, 0x42,
	0xbc, 0x3b, 0x02, 0xa6, 0x7f, 0x7b, 0x77, 0x32, 0x11, 0x2e, 0xe5, 0x23, 0x2c, 0xa3, 0x23, 0x74,
	0x7f, 0x5e, 0x74, 0x24, 0xff, 0x23, 0x74, 0xd8, 0xe1, 0x16, 0x5c, 0x83, 0xbc, 0x23, 0xe6, 0x38,
	0x13, 0x9c, 0x3c, 0x47, 0x8b, 0x0b, 0x42, 0xe9, 0x3b, 0x68, 0xa4, 0xc3, 0x64, 0x0e, 0xa6, 0x1c,
	0x09, 0xfc, 0x23, 0x6c, 0x2b, 0x46, 0x7e, 0x3a, 0x4c, 0x0f, 0x54, 0x98, 0x6e, 0xea, 0x60, 0x4a,
	0x80, 0x88, 0x63, 0x28, 0x39, 0xe1, 0x5d, 0xe2, 0x4f, 0xa6, 0x94, 0xfc, 0x77, 0xc2, 0xe7, 0x63,
	0x58, 0x40, 0xf3, 0x79, 0x63, 0x58, 0xc2, 0x3f, 0xda, 0x9d, 0xb7, 0xf0, 0x3f, 0xc1, 0xec, 0x0d,
	0x4d, 0x9f, 0xb0, 0xec, 0xbd, 0x94, 0x0d, 0x22, 0x7f, 0x15, 0x79, 0x92, 0x10, 0xf9, 0xeb, 0x36,
	0x54, 0x59, 0x52, 0x21, 0xfd, 0x68, 0x9e, 0xc8, 0x53, 0x0a, 0x11, 0xff, 0x52, 0x80, 0x86, 0xbc,
	0x66, 0xdb, 0x9d, 0x78, 0xa6, 0x1f, 0xbb, 0x7e, 0x07, 0x6a, 0xa1, 0x24, 0xc7, 0x89, 0x65, 0xbb,
	0x02, 0x2f, 0x04, 0x54, 0x6a, 0xa6, 0x11, 0x2d, 0xb8, 0xc4, 0xd7, 0x4b, 0x14, 0x70, 0x33, 0xd2,
	0x64, 0xfc, 0xd7, 0x9c, 0x21, 0xce, 0xf7, 0xb6, 0x3f, 0x89, 0x0c, 0x69, 0xc1, 0xa5, 0x17, 0x66,
	0x30, 0x24, 0x73, 0x96, 0xa4, 0xc9, 0x99, 0xa6, 0xdc, 0x85, 0x4d, 0xee, 0x9c, 0x1d, 0xb8, 0x8e,
	0x41, 0x82, 0xe9, 0x38, 0x3a, 0xb0, 0x73, 0x74, 0x74, 0x1f, 0x2e, 0xcb, 0xf6, 0x09, 0x5b, 0x44,
	0x18, 0xea, 0x58, 0x78, 0x08, 0x9b, 0xb2, 0xf5, 0x99, 0xa7, 0xea, 0x09, 0x5c, 0x8f, 0xa2, 0x90,
	0x21, 0xc8, 0x0b, 0x86, 0xc4, 0x27, 0x7e, 0xb8, 0xf2, 0x44, 0xf0, 0x0f, 0x70, 0x59, 0x5e, 0xe9,
	0xd3, 0x83, 0x74, 0x57, 0x0d, 0xd2, 0xff, 0xeb, 0x82, 0x34, 0x76, 0x26, 0x0a, 0xd1, 0x3f, 0x0a,
	0x70, 0xd9, 0x20, 0xe6, 0x98, 0xda, 0x13, 0xb2, 0xa8, 0x46, 0x90, 0x2b, 0x4c, 0xbe, 0x17, 0x49,
	0x85, 0x79, 0x17, 0x36, 0xd3, 0x37, 0x48, 0xb4, 0x1b, 0x69, 0xba, 0x72, 0x13, 0xc9, 0xe5, 0xe6,
	0x4a, 0xea, 0x26, 0x92, 0xeb, 0xce, 0x9f, 0x0b, 0x70, 0x35, 0x65, 0xe7, 0xa7, 0x23, 0xf5, 0x8d,
	0x8a, 0x54, 0x53, 0x41, 0x4a, 0x83, 0x46, 0x04, 0xd6, 0x59, 0x82, 0xd5, 0xa2, 0x8c, 0x9d, 0xaa,
	0xa4, 0x39, 0x5c, 0x32, 0xe9, 0x63, 0x10, 0x53, 0xbc, 0x3f, 0x77, 0x42, 0x5e, 0xca, 0x7b, 0x4d,
	0x46, 0xfe, 0x55, 0x0a, 0x95, 0x45, 0xc9, 0x46, 0xe7, 0x5c, 0xf1, 0x23, 0xc3, 0xa1, 0xb4, 0x64,
	0x38, 0x9c, 0xfb, 0x76, 0x5f, 0x0a, 0x10, 0xcd, 0xf5, 0xfe, 0x12, 0x36, 0xe3, 0x07, 0xc2, 0xe2,
	0xd5, 0x6f, 0x40, 0x39, 0x79, 0x63, 0x70, 0x2c, 0x12, 0x02, 0x6e, 0x41, 0xe5, 0xa9, 0xef, 0xbb,
	0xbe, 0xa4, 0x27, 0xc2, 0x4d, 0xe8, 0x89, 0x62, 0x01, 0xc3, 0x7a, 0x28, 0xb9, 0x67, 0x8d, 0x98,
	0x47, 0x47, 0xc1, 0xe0, 0x90, 0x38, 0xa1, 0xd0, 0xaa, 0x21, 0x46, 0xf8, 0x29, 0x54, 0x3b, 0x8e,
	0x37, 0x4d, 0x5e, 0x56, 0x0f, 0xd8, 0xb3, 0x96, 0xff, 0x8b, 0xb7, 0x43, 0x5d, 0x7d, 0x3b, 0x24,
	0x0f, 0x49, 0x23, 0x96, 0xc4, 0xcf, 0xa0, 0xf6, 0x7a, 0x4a, 0xcf, 0xad, 0x67, 0xe7, 0xef, 0x0a,
	0xd4, 0x8e, 0x62, 0x06, 0xbb, 0xbf, 0xd1, 0x3e, 0x54, 0x8e, 0x09, 0x3d, 0x73, 0xfd, 0x51, 0xe8,
	0x0c, 0xba, 0xa6, 0xa8, 0x91, 0xa1, 0x68, 0x5c, 0x99, 0x67, 0xb1, 0xe7, 0xef, 0x05, 0xb4, 0x0b,
	0xe5, 0xbd, 0x60, 0xf4, 0xda, 0x19, 0xdb, 0x0e, 0x41, 0x5b, 0xea, 0x75, 0x67, 0x3b, 0x83, 0x46,
	0x8a, 0xe4, 0x3a, 0x03, 0x7c, 0x01, 0x3d, 0x82, 0x6a, 0xb8, 0x23, 0xd4, 0xb7, 0xbd, 0xb0, 0x41,
	0xa0, 0xaa, 0x8f, 0xfa, 0x06, 0x8d, 0x4d, 0x85, 0xcc, 0x17, 0x7c, 0x06, 0x55, 0xa5, 0x69, 0x80,
	0xbe, 0x54, 0x84, 0x74, 0x0d, 0x05, 0xad, 0x9e, 0xc7, 0xb0, 0x7e, 0x4c, 0xce, 0xf8, 0x7b, 0xff,
	0xaa, 0xc2, 0x8f, 0x1f, 0xf8, 0x8d, 0x6b, 0x7a, 0x3a, 0x57, 0xf0, 0x02, 0x6a, 0xea, 0xbb, 0x02,
	0xe1, 0x9c, 0x47, 0x47, 0x9e, 0x29, 0x89, 0x26, 0x71, 0xce, 0xf4, 0x9a, 0xd4, 0x4b, 0x27, 0x0b,
	0x1c, 0xa5, 0x4c, 0x4d, 0x81, 0xa3, 0x2b, 0x93, 0x17, 0x58, 0x24, 0x8e, 0x9c, 0xde, 0x22, 0xf5,
	0xd4, 0x6b, 0x35, 0x1d, 0x40, 0x45, 0x4e, 0x7b, 0xa8, 0x99, 0x99, 0x11, 0xf3, 0xb4, 0x1c, 0xaa,
	0x95, 0x00, 0xdb, 0x09, 0x74, 0x3b, 0x53, 0x93, 0x54, 0xe3, 0x69, 0xb5, 0x19, 0x6a, 0xb6, 0x17,
	0xe5, 0x19, 0xfa, 0x3a, 0x53, 0xa1, 0x5a, 0xc0, 0x2d, 0xa7, 0x33, 0x2c, 0x61, 0x72, 0x75, 0xca,
	0xb5, 0x98, 0x56, 0xe7, 0x4b, 0xb8, 0x94, 0x4a, 0x84, 0xe8, 0x56, 0x5e, 0x9a, 0x5c, 0x52, 0x57,
	0x14, 0x64, 0xb7, 0xf2, 0x92, 0xce, 0x92, 0xba, 0xa2, 0xf0, 0xb8, 0x95, 0x77, 0x5f, 0xe7, 0xe9,
	0xda, 0x83, 0x4a, 0x8f, 0xd0, 0xa4, 0xc7, 0x93, 0xaa, 0x98, 0x52, 0x57, 0xbb, 0x56, 0x45, 0x07,
	0xae, 0xf1, 0x1e, 0x16, 0x2b, 0x84, 0x84, 0xe0, 0x89, 0xcb, 0x2f, 0x02, 0x94, 0x79, 0x35, 0x66,
	0xc4, 0x3d, 0x24, 0x9d, 0x35, 0xa4, 0xbe, 0xff, 0xe6, 0x5a, 0x6e, 0x8d, 0x4c, 0xdd, 0xf8, 0x02,
	0x3a, 0x02, 0x64, 0x90, 0xb7, 0x53, 0x12, 0x50, 0xd1, 0x09, 0x3a, 0xb4, 0x03, 0x9a, 0xb6, 0x26,
	0xe9, 0xa3, 0x35, 0xae, 0xeb, 0x38, 0x89, 0xba, 0x5d, 0xb8, 0xd8, 0x23, 0xf4, 0xd8, 0xb6, 0x46,
	0x48, 0xdb, 0x70, 0xd2, 0x7a, 0xf3, 0x04, 0xe0, 0x34, 0x20, 0x3e, 0x6f, 0xcf, 0xa5, 0xbc, 0x99,
	0xeb, 0xd9, 0x69, 0x35, 0x7c, 0x0b, 0xd0, 0xa3, 0xa6, 0x2f, 0xda, 0xa2, 0x8d, 0xd4, 0x75, 0x28,
	0x25, 0x25, 0xdd, 0xec, 0x9d, 0x3f, 0x8b, 0xb0, 0x95, 0xa4, 0x9c, 0xe7, 0x26, 0x25, 0x67, 0xe6,
	0x0c, 0x1d, 0x43, 0xb5, 0x3d, 0x24, 0xd6, 0x28, 0xe9, 0x38, 0x2e, 0x80, 0xf9, 0xba, 0x86, 0x1f,
	0xa7, 0xc7, 0x70, 0xcf, 0x9e, 0x93, 0xb8, 0x14, 0x3b, 0xcf, 0x9e, 0x3d, 0x02, 0xe8, 0x4e, 0x93,
	0xa2, 0xee, 0xa3, 0x22, 0xe7, 0x31, 0x54, 0x0c, 0x62, 0x11, 0xfb, 0x1d, 0xd9, 0x37, 0xa9, 0x35,
	0x44, 0xaa, 0xd1, 0x6a, 0x06, 0xd7, 0x29, 0x78, 0xb3, 0x16, 0xb6, 0xd6, 0x77, 0xff, 0x09, 0x00,
	0x00, 0xff, 0xff, 0x58, 0x85, 0x72, 0x0c, 0x6f, 0x17, 0x00, 0x00,
}
