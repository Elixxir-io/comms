// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mixmessages.proto

/*
Package mixmessages is a generated protocol buffer package.

It is generated from these files:
	mixmessages.proto

It has these top-level messages:
	Ping
	TimePing
	ServerMetrics
	RoundInfo
	RoundBufferInfo
	RoundPublicKey
	NodeTopology
	NodeInfo
	ClientRequest
	IDList
	DSAPublicKey
	DSASignature
	UserRegistration
	UserRegistrationConfirmation
	NonceRequest
	Nonce
	RegistrationConfirmation
	Ack
	Batch
	BatchInfo
	Slot
*/
package mixmessages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The request message asking if server is online
type Ping struct {
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// The request message asking server to add their time
type TimePing struct {
	Times []int64 `protobuf:"varint,1,rep,packed,name=Times" json:"Times,omitempty"`
	// RoundInfo is needed since network topology depends on the round
	Round *RoundInfo `protobuf:"bytes,2,opt,name=Round" json:"Round,omitempty"`
}

func (m *TimePing) Reset()                    { *m = TimePing{} }
func (m *TimePing) String() string            { return proto.CompactTextString(m) }
func (*TimePing) ProtoMessage()               {}
func (*TimePing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TimePing) GetTimes() []int64 {
	if m != nil {
		return m.Times
	}
	return nil
}

func (m *TimePing) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

// The message containing the server metrics from all visited nodes
type ServerMetrics struct {
	MemUsage    []uint32 `protobuf:"varint,1,rep,packed,name=MemUsage" json:"MemUsage,omitempty"`
	ThreadUsage []uint32 `protobuf:"varint,2,rep,packed,name=ThreadUsage" json:"ThreadUsage,omitempty"`
	CpuUsage    []uint32 `protobuf:"varint,3,rep,packed,name=CpuUsage" json:"CpuUsage,omitempty"`
	UpSince     []int64  `protobuf:"varint,4,rep,packed,name=UpSince" json:"UpSince,omitempty"`
	// RoundInfo is needed since network topology depends on the round
	Round *RoundInfo `protobuf:"bytes,5,opt,name=Round" json:"Round,omitempty"`
}

func (m *ServerMetrics) Reset()                    { *m = ServerMetrics{} }
func (m *ServerMetrics) String() string            { return proto.CompactTextString(m) }
func (*ServerMetrics) ProtoMessage()               {}
func (*ServerMetrics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ServerMetrics) GetMemUsage() []uint32 {
	if m != nil {
		return m.MemUsage
	}
	return nil
}

func (m *ServerMetrics) GetThreadUsage() []uint32 {
	if m != nil {
		return m.ThreadUsage
	}
	return nil
}

func (m *ServerMetrics) GetCpuUsage() []uint32 {
	if m != nil {
		return m.CpuUsage
	}
	return nil
}

func (m *ServerMetrics) GetUpSince() []int64 {
	if m != nil {
		return m.UpSince
	}
	return nil
}

func (m *ServerMetrics) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

// The message for Init Round
type RoundInfo struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *RoundInfo) Reset()                    { *m = RoundInfo{} }
func (m *RoundInfo) String() string            { return proto.CompactTextString(m) }
func (*RoundInfo) ProtoMessage()               {}
func (*RoundInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RoundInfo) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// RoundInfo contains the # of precomputations ready for messages, among other
// information
type RoundBufferInfo struct {
	RoundBufferSize uint32 `protobuf:"varint,1,opt,name=RoundBufferSize" json:"RoundBufferSize,omitempty"`
}

func (m *RoundBufferInfo) Reset()                    { *m = RoundBufferInfo{} }
func (m *RoundBufferInfo) String() string            { return proto.CompactTextString(m) }
func (*RoundBufferInfo) ProtoMessage()               {}
func (*RoundBufferInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RoundBufferInfo) GetRoundBufferSize() uint32 {
	if m != nil {
		return m.RoundBufferSize
	}
	return 0
}

//
type RoundPublicKey struct {
	Round *RoundInfo `protobuf:"bytes,1,opt,name=Round" json:"Round,omitempty"`
	Key   []byte     `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
}

func (m *RoundPublicKey) Reset()                    { *m = RoundPublicKey{} }
func (m *RoundPublicKey) String() string            { return proto.CompactTextString(m) }
func (*RoundPublicKey) ProtoMessage()               {}
func (*RoundPublicKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RoundPublicKey) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *RoundPublicKey) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// Contains network information about all Nodes
type NodeTopology struct {
	Topology []*NodeInfo `protobuf:"bytes,1,rep,name=Topology" json:"Topology,omitempty"`
}

func (m *NodeTopology) Reset()                    { *m = NodeTopology{} }
func (m *NodeTopology) String() string            { return proto.CompactTextString(m) }
func (*NodeTopology) ProtoMessage()               {}
func (*NodeTopology) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *NodeTopology) GetTopology() []*NodeInfo {
	if m != nil {
		return m.Topology
	}
	return nil
}

// Contains network information about a single Node
type NodeInfo struct {
	Id        []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	IpAddress string `protobuf:"bytes,2,opt,name=IpAddress" json:"IpAddress,omitempty"`
	TlsCert   string `protobuf:"bytes,3,opt,name=TlsCert" json:"TlsCert,omitempty"`
	Signature []byte `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NodeInfo) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *NodeInfo) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *NodeInfo) GetTlsCert() string {
	if m != nil {
		return m.TlsCert
	}
	return ""
}

func (m *NodeInfo) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// ClientRequest message for clients to poll new CMIX messages
type ClientRequest struct {
	UserID        []byte `protobuf:"bytes,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	LastMessageID string `protobuf:"bytes,2,opt,name=LastMessageID" json:"LastMessageID,omitempty"`
}

func (m *ClientRequest) Reset()                    { *m = ClientRequest{} }
func (m *ClientRequest) String() string            { return proto.CompactTextString(m) }
func (*ClientRequest) ProtoMessage()               {}
func (*ClientRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ClientRequest) GetUserID() []byte {
	if m != nil {
		return m.UserID
	}
	return nil
}

func (m *ClientRequest) GetLastMessageID() string {
	if m != nil {
		return m.LastMessageID
	}
	return ""
}

// The message for clients to poll the gateway for Message IDs
type IDList struct {
	IDs []string `protobuf:"bytes,1,rep,name=IDs" json:"IDs,omitempty"`
}

func (m *IDList) Reset()                    { *m = IDList{} }
func (m *IDList) String() string            { return proto.CompactTextString(m) }
func (*IDList) ProtoMessage()               {}
func (*IDList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *IDList) GetIDs() []string {
	if m != nil {
		return m.IDs
	}
	return nil
}

// DSAPublicKey is a public key for the digital signature algorithm
type DSAPublicKey struct {
	Y []byte `protobuf:"bytes,1,opt,name=Y,proto3" json:"Y,omitempty"`
	P []byte `protobuf:"bytes,2,opt,name=P,proto3" json:"P,omitempty"`
	Q []byte `protobuf:"bytes,3,opt,name=Q,proto3" json:"Q,omitempty"`
	G []byte `protobuf:"bytes,4,opt,name=G,proto3" json:"G,omitempty"`
}

func (m *DSAPublicKey) Reset()                    { *m = DSAPublicKey{} }
func (m *DSAPublicKey) String() string            { return proto.CompactTextString(m) }
func (*DSAPublicKey) ProtoMessage()               {}
func (*DSAPublicKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DSAPublicKey) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

func (m *DSAPublicKey) GetP() []byte {
	if m != nil {
		return m.P
	}
	return nil
}

func (m *DSAPublicKey) GetQ() []byte {
	if m != nil {
		return m.Q
	}
	return nil
}

func (m *DSAPublicKey) GetG() []byte {
	if m != nil {
		return m.G
	}
	return nil
}

// DSASignature is a digital signature for the digital signature algorithm
type DSASignature struct {
	Hash []byte `protobuf:"bytes,1,opt,name=Hash,proto3" json:"Hash,omitempty"`
	R    []byte `protobuf:"bytes,2,opt,name=R,proto3" json:"R,omitempty"`
	S    []byte `protobuf:"bytes,3,opt,name=S,proto3" json:"S,omitempty"`
}

func (m *DSASignature) Reset()                    { *m = DSASignature{} }
func (m *DSASignature) String() string            { return proto.CompactTextString(m) }
func (*DSASignature) ProtoMessage()               {}
func (*DSASignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DSASignature) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *DSASignature) GetR() []byte {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *DSASignature) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

// UserRegistration message to initialize registration process
type UserRegistration struct {
	RegistrationCode string        `protobuf:"bytes,1,opt,name=RegistrationCode" json:"RegistrationCode,omitempty"`
	Client           *DSAPublicKey `protobuf:"bytes,2,opt,name=Client" json:"Client,omitempty"`
}

func (m *UserRegistration) Reset()                    { *m = UserRegistration{} }
func (m *UserRegistration) String() string            { return proto.CompactTextString(m) }
func (*UserRegistration) ProtoMessage()               {}
func (*UserRegistration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UserRegistration) GetRegistrationCode() string {
	if m != nil {
		return m.RegistrationCode
	}
	return ""
}

func (m *UserRegistration) GetClient() *DSAPublicKey {
	if m != nil {
		return m.Client
	}
	return nil
}

// UserRegistrationConfirmation to confirm registration with users
type UserRegistrationConfirmation struct {
	// RegistrationServer-Signed Client Public Key
	ClientSignedByServer *DSASignature `protobuf:"bytes,1,opt,name=ClientSignedByServer" json:"ClientSignedByServer,omitempty"`
	Error                string        `protobuf:"bytes,2,opt,name=Error" json:"Error,omitempty"`
}

func (m *UserRegistrationConfirmation) Reset()                    { *m = UserRegistrationConfirmation{} }
func (m *UserRegistrationConfirmation) String() string            { return proto.CompactTextString(m) }
func (*UserRegistrationConfirmation) ProtoMessage()               {}
func (*UserRegistrationConfirmation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *UserRegistrationConfirmation) GetClientSignedByServer() *DSASignature {
	if m != nil {
		return m.ClientSignedByServer
	}
	return nil
}

func (m *UserRegistrationConfirmation) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// NonceRequest message to request nonce from client to server
type NonceRequest struct {
	Salt                 []byte        `protobuf:"bytes,1,opt,name=Salt,proto3" json:"Salt,omitempty"`
	Client               *DSAPublicKey `protobuf:"bytes,2,opt,name=Client" json:"Client,omitempty"`
	ClientSignedByServer *DSASignature `protobuf:"bytes,3,opt,name=ClientSignedByServer" json:"ClientSignedByServer,omitempty"`
}

func (m *NonceRequest) Reset()                    { *m = NonceRequest{} }
func (m *NonceRequest) String() string            { return proto.CompactTextString(m) }
func (*NonceRequest) ProtoMessage()               {}
func (*NonceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *NonceRequest) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *NonceRequest) GetClient() *DSAPublicKey {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *NonceRequest) GetClientSignedByServer() *DSASignature {
	if m != nil {
		return m.ClientSignedByServer
	}
	return nil
}

// Nonce message to reply to client from server
type Nonce struct {
	Nonce []byte `protobuf:"bytes,1,opt,name=Nonce,proto3" json:"Nonce,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=Error" json:"Error,omitempty"`
}

func (m *Nonce) Reset()                    { *m = Nonce{} }
func (m *Nonce) String() string            { return proto.CompactTextString(m) }
func (*Nonce) ProtoMessage()               {}
func (*Nonce) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Nonce) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Nonce) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// RegistrationConfirmation returning proof of registration
type RegistrationConfirmation struct {
	ClientSignedByServer *DSASignature `protobuf:"bytes,1,opt,name=ClientSignedByServer" json:"ClientSignedByServer,omitempty"`
	Server               *DSAPublicKey `protobuf:"bytes,2,opt,name=Server" json:"Server,omitempty"`
	Error                string        `protobuf:"bytes,3,opt,name=Error" json:"Error,omitempty"`
}

func (m *RegistrationConfirmation) Reset()                    { *m = RegistrationConfirmation{} }
func (m *RegistrationConfirmation) String() string            { return proto.CompactTextString(m) }
func (*RegistrationConfirmation) ProtoMessage()               {}
func (*RegistrationConfirmation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RegistrationConfirmation) GetClientSignedByServer() *DSASignature {
	if m != nil {
		return m.ClientSignedByServer
	}
	return nil
}

func (m *RegistrationConfirmation) GetServer() *DSAPublicKey {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *RegistrationConfirmation) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Ack generic message containing an Error field
type Ack struct {
	Error string `protobuf:"bytes,1,opt,name=Error" json:"Error,omitempty"`
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Ack) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Batch struct {
	Round    *RoundInfo `protobuf:"bytes,1,opt,name=Round" json:"Round,omitempty"`
	ForPhase int32      `protobuf:"varint,2,opt,name=ForPhase" json:"ForPhase,omitempty"`
	Slots    []*Slot    `protobuf:"bytes,3,rep,name=slots" json:"slots,omitempty"`
}

func (m *Batch) Reset()                    { *m = Batch{} }
func (m *Batch) String() string            { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()               {}
func (*Batch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Batch) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *Batch) GetForPhase() int32 {
	if m != nil {
		return m.ForPhase
	}
	return 0
}

func (m *Batch) GetSlots() []*Slot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Used as part of header for streaming post phase
type BatchInfo struct {
	Round     *RoundInfo `protobuf:"bytes,1,opt,name=Round" json:"Round,omitempty"`
	ForPhase  int32      `protobuf:"varint,2,opt,name=ForPhase" json:"ForPhase,omitempty"`
	BatchSize uint32     `protobuf:"varint,3,opt,name=BatchSize" json:"BatchSize,omitempty"`
}

func (m *BatchInfo) Reset()                    { *m = BatchInfo{} }
func (m *BatchInfo) String() string            { return proto.CompactTextString(m) }
func (*BatchInfo) ProtoMessage()               {}
func (*BatchInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *BatchInfo) GetRound() *RoundInfo {
	if m != nil {
		return m.Round
	}
	return nil
}

func (m *BatchInfo) GetForPhase() int32 {
	if m != nil {
		return m.ForPhase
	}
	return 0
}

func (m *BatchInfo) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

type Slot struct {
	// Index in batch this slot belongs in
	Index uint32 `protobuf:"varint,1,opt,name=Index" json:"Index,omitempty"`
	// Precomputation fields
	EncryptedMessageKeys            []byte `protobuf:"bytes,2,opt,name=EncryptedMessageKeys,proto3" json:"EncryptedMessageKeys,omitempty"`
	EncryptedAssociatedDataKeys     []byte `protobuf:"bytes,3,opt,name=EncryptedAssociatedDataKeys,proto3" json:"EncryptedAssociatedDataKeys,omitempty"`
	PartialMessageCypherText        []byte `protobuf:"bytes,4,opt,name=PartialMessageCypherText,proto3" json:"PartialMessageCypherText,omitempty"`
	PartialAssociatedDataCypherText []byte `protobuf:"bytes,5,opt,name=PartialAssociatedDataCypherText,proto3" json:"PartialAssociatedDataCypherText,omitempty"`
	PartialRoundPublicCypherKey     []byte `protobuf:"bytes,6,opt,name=PartialRoundPublicCypherKey,proto3" json:"PartialRoundPublicCypherKey,omitempty"`
	// Realtime/client fields
	SenderID       []byte   `protobuf:"bytes,7,opt,name=SenderID,proto3" json:"SenderID,omitempty"`
	MessagePayload []byte   `protobuf:"bytes,8,opt,name=MessagePayload,proto3" json:"MessagePayload,omitempty"`
	AssociatedData []byte   `protobuf:"bytes,9,opt,name=AssociatedData,proto3" json:"AssociatedData,omitempty"`
	Salt           []byte   `protobuf:"bytes,10,opt,name=Salt,proto3" json:"Salt,omitempty"`
	KMACs          [][]byte `protobuf:"bytes,11,rep,name=KMACs,proto3" json:"KMACs,omitempty"`
}

func (m *Slot) Reset()                    { *m = Slot{} }
func (m *Slot) String() string            { return proto.CompactTextString(m) }
func (*Slot) ProtoMessage()               {}
func (*Slot) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Slot) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Slot) GetEncryptedMessageKeys() []byte {
	if m != nil {
		return m.EncryptedMessageKeys
	}
	return nil
}

func (m *Slot) GetEncryptedAssociatedDataKeys() []byte {
	if m != nil {
		return m.EncryptedAssociatedDataKeys
	}
	return nil
}

func (m *Slot) GetPartialMessageCypherText() []byte {
	if m != nil {
		return m.PartialMessageCypherText
	}
	return nil
}

func (m *Slot) GetPartialAssociatedDataCypherText() []byte {
	if m != nil {
		return m.PartialAssociatedDataCypherText
	}
	return nil
}

func (m *Slot) GetPartialRoundPublicCypherKey() []byte {
	if m != nil {
		return m.PartialRoundPublicCypherKey
	}
	return nil
}

func (m *Slot) GetSenderID() []byte {
	if m != nil {
		return m.SenderID
	}
	return nil
}

func (m *Slot) GetMessagePayload() []byte {
	if m != nil {
		return m.MessagePayload
	}
	return nil
}

func (m *Slot) GetAssociatedData() []byte {
	if m != nil {
		return m.AssociatedData
	}
	return nil
}

func (m *Slot) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *Slot) GetKMACs() [][]byte {
	if m != nil {
		return m.KMACs
	}
	return nil
}

func init() {
	proto.RegisterType((*Ping)(nil), "mixmessages.Ping")
	proto.RegisterType((*TimePing)(nil), "mixmessages.TimePing")
	proto.RegisterType((*ServerMetrics)(nil), "mixmessages.ServerMetrics")
	proto.RegisterType((*RoundInfo)(nil), "mixmessages.RoundInfo")
	proto.RegisterType((*RoundBufferInfo)(nil), "mixmessages.RoundBufferInfo")
	proto.RegisterType((*RoundPublicKey)(nil), "mixmessages.RoundPublicKey")
	proto.RegisterType((*NodeTopology)(nil), "mixmessages.NodeTopology")
	proto.RegisterType((*NodeInfo)(nil), "mixmessages.NodeInfo")
	proto.RegisterType((*ClientRequest)(nil), "mixmessages.ClientRequest")
	proto.RegisterType((*IDList)(nil), "mixmessages.IDList")
	proto.RegisterType((*DSAPublicKey)(nil), "mixmessages.DSAPublicKey")
	proto.RegisterType((*DSASignature)(nil), "mixmessages.DSASignature")
	proto.RegisterType((*UserRegistration)(nil), "mixmessages.UserRegistration")
	proto.RegisterType((*UserRegistrationConfirmation)(nil), "mixmessages.UserRegistrationConfirmation")
	proto.RegisterType((*NonceRequest)(nil), "mixmessages.NonceRequest")
	proto.RegisterType((*Nonce)(nil), "mixmessages.Nonce")
	proto.RegisterType((*RegistrationConfirmation)(nil), "mixmessages.RegistrationConfirmation")
	proto.RegisterType((*Ack)(nil), "mixmessages.Ack")
	proto.RegisterType((*Batch)(nil), "mixmessages.Batch")
	proto.RegisterType((*BatchInfo)(nil), "mixmessages.BatchInfo")
	proto.RegisterType((*Slot)(nil), "mixmessages.Slot")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Node service

type NodeClient interface {
	// Handles AskOnline
	AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error)
	// Handles RoundtripPing
	RoundtripPing(ctx context.Context, in *TimePing, opts ...grpc.CallOption) (*Ack, error)
	// GetServerMetrics returns server metrics
	GetServerMetrics(ctx context.Context, in *ServerMetrics, opts ...grpc.CallOption) (*Ack, error)
	// CreatesNewRound makes a new round with a certain ID
	CreateNewRound(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error)
	// PostNewBatch sends a batch to be processed in the server's realtime
	PostNewBatch(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error)
	// FinishRealtime broadcasts when realtime is complete
	FinishRealtime(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error)
	// PostPhase runs a cMix phase on another node
	PostPhase(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error)
	// StreamPostPhase runs a cMix phase on another node
	// by using unary streaming of slots
	StreamPostPhase(ctx context.Context, opts ...grpc.CallOption) (Node_StreamPostPhaseClient, error)
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(ctx context.Context, in *RoundBufferInfo, opts ...grpc.CallOption) (*RoundBufferInfo, error)
	// RequestNonce generates a nonce for user registration
	RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error)
	// ConfirmRegistration uses a nonce confirmation to finalize user registration
	ConfirmRegistration(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error)
	// PostRoundPublicKey sets the public cypher key for a round on other nodes
	PostRoundPublicKey(ctx context.Context, in *RoundPublicKey, opts ...grpc.CallOption) (*Ack, error)
	// PostPrecompResult finalizes the precomputation results with each node from the last node
	// sending the final Message and AD precomputations
	PostPrecompResult(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error)
	// The gateway calls GetCompletedBatch to get any finished batch from a node
	GetCompletedBatch(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Batch, error)
	// Obtains a network topology from the Permissioning Server
	DownloadTopology(ctx context.Context, in *NodeTopology, opts ...grpc.CallOption) (*Ack, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) AskOnline(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/AskOnline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RoundtripPing(ctx context.Context, in *TimePing, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/RoundtripPing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetServerMetrics(ctx context.Context, in *ServerMetrics, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/GetServerMetrics", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CreateNewRound(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/CreateNewRound", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostNewBatch(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/PostNewBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) FinishRealtime(ctx context.Context, in *RoundInfo, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/FinishRealtime", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostPhase(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/PostPhase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) StreamPostPhase(ctx context.Context, opts ...grpc.CallOption) (Node_StreamPostPhaseClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Node_serviceDesc.Streams[0], c.cc, "/mixmessages.Node/StreamPostPhase", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeStreamPostPhaseClient{stream}
	return x, nil
}

type Node_StreamPostPhaseClient interface {
	Send(*Slot) error
	CloseAndRecv() (*Ack, error)
	grpc.ClientStream
}

type nodeStreamPostPhaseClient struct {
	grpc.ClientStream
}

func (x *nodeStreamPostPhaseClient) Send(m *Slot) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeStreamPostPhaseClient) CloseAndRecv() (*Ack, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeClient) GetRoundBufferInfo(ctx context.Context, in *RoundBufferInfo, opts ...grpc.CallOption) (*RoundBufferInfo, error) {
	out := new(RoundBufferInfo)
	err := grpc.Invoke(ctx, "/mixmessages.Node/GetRoundBufferInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error) {
	out := new(Nonce)
	err := grpc.Invoke(ctx, "/mixmessages.Node/RequestNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) ConfirmRegistration(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error) {
	out := new(RegistrationConfirmation)
	err := grpc.Invoke(ctx, "/mixmessages.Node/ConfirmRegistration", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostRoundPublicKey(ctx context.Context, in *RoundPublicKey, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/PostRoundPublicKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) PostPrecompResult(ctx context.Context, in *Batch, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/PostPrecompResult", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetCompletedBatch(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*Batch, error) {
	out := new(Batch)
	err := grpc.Invoke(ctx, "/mixmessages.Node/GetCompletedBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DownloadTopology(ctx context.Context, in *NodeTopology, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Node/DownloadTopology", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Node service

type NodeServer interface {
	// Handles AskOnline
	AskOnline(context.Context, *Ping) (*Ack, error)
	// Handles RoundtripPing
	RoundtripPing(context.Context, *TimePing) (*Ack, error)
	// GetServerMetrics returns server metrics
	GetServerMetrics(context.Context, *ServerMetrics) (*Ack, error)
	// CreatesNewRound makes a new round with a certain ID
	CreateNewRound(context.Context, *RoundInfo) (*Ack, error)
	// PostNewBatch sends a batch to be processed in the server's realtime
	PostNewBatch(context.Context, *Batch) (*Ack, error)
	// FinishRealtime broadcasts when realtime is complete
	FinishRealtime(context.Context, *RoundInfo) (*Ack, error)
	// PostPhase runs a cMix phase on another node
	PostPhase(context.Context, *Batch) (*Ack, error)
	// StreamPostPhase runs a cMix phase on another node
	// by using unary streaming of slots
	StreamPostPhase(Node_StreamPostPhaseServer) error
	// GetRoundBufferInfo returns the # of rounds ready for messages
	GetRoundBufferInfo(context.Context, *RoundBufferInfo) (*RoundBufferInfo, error)
	// RequestNonce generates a nonce for user registration
	RequestNonce(context.Context, *NonceRequest) (*Nonce, error)
	// ConfirmRegistration uses a nonce confirmation to finalize user registration
	ConfirmRegistration(context.Context, *DSASignature) (*RegistrationConfirmation, error)
	// PostRoundPublicKey sets the public cypher key for a round on other nodes
	PostRoundPublicKey(context.Context, *RoundPublicKey) (*Ack, error)
	// PostPrecompResult finalizes the precomputation results with each node from the last node
	// sending the final Message and AD precomputations
	PostPrecompResult(context.Context, *Batch) (*Ack, error)
	// The gateway calls GetCompletedBatch to get any finished batch from a node
	GetCompletedBatch(context.Context, *Ping) (*Batch, error)
	// Obtains a network topology from the Permissioning Server
	DownloadTopology(context.Context, *NodeTopology) (*Ack, error)
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_AskOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AskOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/AskOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AskOnline(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RoundtripPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimePing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RoundtripPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/RoundtripPing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RoundtripPing(ctx, req.(*TimePing))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetServerMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerMetrics)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetServerMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetServerMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetServerMetrics(ctx, req.(*ServerMetrics))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CreateNewRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CreateNewRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/CreateNewRound",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CreateNewRound(ctx, req.(*RoundInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostNewBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostNewBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostNewBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostNewBatch(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_FinishRealtime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).FinishRealtime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/FinishRealtime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).FinishRealtime(ctx, req.(*RoundInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostPhase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostPhase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostPhase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostPhase(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_StreamPostPhase_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeServer).StreamPostPhase(&nodeStreamPostPhaseServer{stream})
}

type Node_StreamPostPhaseServer interface {
	SendAndClose(*Ack) error
	Recv() (*Slot, error)
	grpc.ServerStream
}

type nodeStreamPostPhaseServer struct {
	grpc.ServerStream
}

func (x *nodeStreamPostPhaseServer) SendAndClose(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeStreamPostPhaseServer) Recv() (*Slot, error) {
	m := new(Slot)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Node_GetRoundBufferInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundBufferInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetRoundBufferInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetRoundBufferInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetRoundBufferInfo(ctx, req.(*RoundBufferInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RequestNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RequestNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/RequestNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RequestNonce(ctx, req.(*NonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_ConfirmRegistration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSASignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).ConfirmRegistration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/ConfirmRegistration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).ConfirmRegistration(ctx, req.(*DSASignature))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostRoundPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoundPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostRoundPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostRoundPublicKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostRoundPublicKey(ctx, req.(*RoundPublicKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_PostPrecompResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Batch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).PostPrecompResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/PostPrecompResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).PostPrecompResult(ctx, req.(*Batch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetCompletedBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetCompletedBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/GetCompletedBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetCompletedBatch(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DownloadTopology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeTopology)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DownloadTopology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Node/DownloadTopology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DownloadTopology(ctx, req.(*NodeTopology))
	}
	return interceptor(ctx, in, info, handler)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AskOnline",
			Handler:    _Node_AskOnline_Handler,
		},
		{
			MethodName: "RoundtripPing",
			Handler:    _Node_RoundtripPing_Handler,
		},
		{
			MethodName: "GetServerMetrics",
			Handler:    _Node_GetServerMetrics_Handler,
		},
		{
			MethodName: "CreateNewRound",
			Handler:    _Node_CreateNewRound_Handler,
		},
		{
			MethodName: "PostNewBatch",
			Handler:    _Node_PostNewBatch_Handler,
		},
		{
			MethodName: "FinishRealtime",
			Handler:    _Node_FinishRealtime_Handler,
		},
		{
			MethodName: "PostPhase",
			Handler:    _Node_PostPhase_Handler,
		},
		{
			MethodName: "GetRoundBufferInfo",
			Handler:    _Node_GetRoundBufferInfo_Handler,
		},
		{
			MethodName: "RequestNonce",
			Handler:    _Node_RequestNonce_Handler,
		},
		{
			MethodName: "ConfirmRegistration",
			Handler:    _Node_ConfirmRegistration_Handler,
		},
		{
			MethodName: "PostRoundPublicKey",
			Handler:    _Node_PostRoundPublicKey_Handler,
		},
		{
			MethodName: "PostPrecompResult",
			Handler:    _Node_PostPrecompResult_Handler,
		},
		{
			MethodName: "GetCompletedBatch",
			Handler:    _Node_GetCompletedBatch_Handler,
		},
		{
			MethodName: "DownloadTopology",
			Handler:    _Node_DownloadTopology_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPostPhase",
			Handler:       _Node_StreamPostPhase_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "mixmessages.proto",
}

// Client API for Gateway service

type GatewayClient interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*IDList, error)
	// GetMessage a Batch from the gateway for the given message information
	GetMessage(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*Slot, error)
	// PutMessage on the cMix Gateway
	PutMessage(ctx context.Context, in *Slot, opts ...grpc.CallOption) (*Ack, error)
	// RequestNonce returns a Nonce to the user
	RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error)
	// ConfirmNonce takes a client signed nonce for Registration Nonce Confirmation
	ConfirmNonce(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error)
}

type gatewayClient struct {
	cc *grpc.ClientConn
}

func NewGatewayClient(cc *grpc.ClientConn) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) CheckMessages(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*IDList, error) {
	out := new(IDList)
	err := grpc.Invoke(ctx, "/mixmessages.Gateway/CheckMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GetMessage(ctx context.Context, in *ClientRequest, opts ...grpc.CallOption) (*Slot, error) {
	out := new(Slot)
	err := grpc.Invoke(ctx, "/mixmessages.Gateway/GetMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PutMessage(ctx context.Context, in *Slot, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/mixmessages.Gateway/PutMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) RequestNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*Nonce, error) {
	out := new(Nonce)
	err := grpc.Invoke(ctx, "/mixmessages.Gateway/RequestNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ConfirmNonce(ctx context.Context, in *DSASignature, opts ...grpc.CallOption) (*RegistrationConfirmation, error) {
	out := new(RegistrationConfirmation)
	err := grpc.Invoke(ctx, "/mixmessages.Gateway/ConfirmNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gateway service

type GatewayServer interface {
	// Request a list of MessageIDs from the gateway for the given UserID
	CheckMessages(context.Context, *ClientRequest) (*IDList, error)
	// GetMessage a Batch from the gateway for the given message information
	GetMessage(context.Context, *ClientRequest) (*Slot, error)
	// PutMessage on the cMix Gateway
	PutMessage(context.Context, *Slot) (*Ack, error)
	// RequestNonce returns a Nonce to the user
	RequestNonce(context.Context, *NonceRequest) (*Nonce, error)
	// ConfirmNonce takes a client signed nonce for Registration Nonce Confirmation
	ConfirmNonce(context.Context, *DSASignature) (*RegistrationConfirmation, error)
}

func RegisterGatewayServer(s *grpc.Server, srv GatewayServer) {
	s.RegisterService(&_Gateway_serviceDesc, srv)
}

func _Gateway_CheckMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CheckMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/CheckMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CheckMessages(ctx, req.(*ClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/GetMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GetMessage(ctx, req.(*ClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PutMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Slot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PutMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/PutMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PutMessage(ctx, req.(*Slot))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_RequestNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).RequestNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/RequestNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).RequestNonce(ctx, req.(*NonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ConfirmNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSASignature)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ConfirmNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Gateway/ConfirmNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ConfirmNonce(ctx, req.(*DSASignature))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckMessages",
			Handler:    _Gateway_CheckMessages_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _Gateway_GetMessage_Handler,
		},
		{
			MethodName: "PutMessage",
			Handler:    _Gateway_PutMessage_Handler,
		},
		{
			MethodName: "RequestNonce",
			Handler:    _Gateway_RequestNonce_Handler,
		},
		{
			MethodName: "ConfirmNonce",
			Handler:    _Gateway_ConfirmNonce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

// Client API for Registration service

type RegistrationClient interface {
	// Client & RegistrationServer Communication
	RegisterUser(ctx context.Context, in *UserRegistration, opts ...grpc.CallOption) (*UserRegistrationConfirmation, error)
}

type registrationClient struct {
	cc *grpc.ClientConn
}

func NewRegistrationClient(cc *grpc.ClientConn) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) RegisterUser(ctx context.Context, in *UserRegistration, opts ...grpc.CallOption) (*UserRegistrationConfirmation, error) {
	out := new(UserRegistrationConfirmation)
	err := grpc.Invoke(ctx, "/mixmessages.Registration/RegisterUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registration service

type RegistrationServer interface {
	// Client & RegistrationServer Communication
	RegisterUser(context.Context, *UserRegistration) (*UserRegistrationConfirmation, error)
}

func RegisterRegistrationServer(s *grpc.Server, srv RegistrationServer) {
	s.RegisterService(&_Registration_serviceDesc, srv)
}

func _Registration_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mixmessages.Registration/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).RegisterUser(ctx, req.(*UserRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mixmessages.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _Registration_RegisterUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixmessages.proto",
}

func init() { proto.RegisterFile("mixmessages.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x36, 0xad, 0x83, 0xad, 0x91, 0xe4, 0xc8, 0x1b, 0xff, 0x81, 0x22, 0xfb, 0x47, 0x0d, 0xa2,
	0x07, 0xb7, 0x28, 0x02, 0x44, 0x01, 0x7a, 0x91, 0xf4, 0x24, 0x4b, 0x89, 0x22, 0x38, 0x72, 0x95,
	0x95, 0x73, 0x91, 0xde, 0x31, 0xe2, 0xd8, 0x62, 0x4d, 0x91, 0xca, 0xee, 0xaa, 0x8e, 0x72, 0xdb,
	0x57, 0xe9, 0x0b, 0xb4, 0xcf, 0x52, 0xf4, 0x39, 0xfa, 0x08, 0xc5, 0x1e, 0x48, 0x91, 0x12, 0xe5,
	0x38, 0x69, 0xd1, 0xbb, 0x9d, 0xc3, 0xce, 0x7c, 0x33, 0x9c, 0x99, 0x1d, 0xc2, 0xee, 0xc4, 0x7b,
	0x33, 0x41, 0xce, 0x9d, 0x0b, 0xe4, 0xf7, 0xa6, 0x2c, 0x14, 0x21, 0x29, 0x27, 0x58, 0x76, 0x11,
	0xf2, 0x03, 0x2f, 0xb8, 0xb0, 0x4f, 0x61, 0xfb, 0xcc, 0x9b, 0xa0, 0x3c, 0x93, 0x3d, 0x28, 0xc8,
	0x33, 0xaf, 0x5b, 0x87, 0xb9, 0xa3, 0x1c, 0xd5, 0x04, 0xf9, 0x12, 0x0a, 0x34, 0x9c, 0x05, 0x6e,
	0x7d, 0xf3, 0xd0, 0x3a, 0x2a, 0x37, 0xef, 0xdc, 0x4b, 0x5a, 0x56, 0x92, 0x5e, 0x70, 0x1e, 0x52,
	0xad, 0x64, 0xff, 0x66, 0x41, 0x75, 0x88, 0xec, 0x67, 0x64, 0x7d, 0x14, 0xcc, 0x1b, 0x71, 0xd2,
	0x80, 0xed, 0x3e, 0x4e, 0x5e, 0x48, 0x7d, 0x65, 0xb8, 0x4a, 0x63, 0x9a, 0x1c, 0x42, 0xf9, 0x6c,
	0xcc, 0xd0, 0x71, 0xb5, 0x78, 0x53, 0x89, 0x93, 0x2c, 0x79, 0xbb, 0x3d, 0x9d, 0x69, 0x71, 0x4e,
	0xdf, 0x8e, 0x68, 0x52, 0x87, 0xad, 0x17, 0xd3, 0xa1, 0x17, 0x8c, 0xb0, 0x9e, 0x57, 0x88, 0x23,
	0x72, 0x81, 0xb9, 0x70, 0x13, 0xcc, 0xfb, 0x50, 0x8a, 0x79, 0x64, 0x07, 0x36, 0x7b, 0x9d, 0xba,
	0x75, 0x68, 0x1d, 0xe5, 0xe9, 0x66, 0xaf, 0x63, 0x3f, 0x82, 0x5b, 0x4a, 0x78, 0x3c, 0x3b, 0x3f,
	0x47, 0xa6, 0x54, 0x8e, 0x52, 0xac, 0xa1, 0xf7, 0x16, 0x95, 0x7e, 0x95, 0x2e, 0xb3, 0xed, 0x01,
	0xec, 0x28, 0xd6, 0x60, 0xf6, 0xca, 0xf7, 0x46, 0x27, 0x38, 0x5f, 0x20, 0xb3, 0x6e, 0x80, 0x8c,
	0xd4, 0x20, 0x77, 0x82, 0x73, 0x95, 0xf9, 0x0a, 0x95, 0x47, 0xbb, 0x05, 0x95, 0xd3, 0xd0, 0xc5,
	0xb3, 0x70, 0x1a, 0xfa, 0xe1, 0xc5, 0x9c, 0xdc, 0x87, 0xed, 0xe8, 0xac, 0xb2, 0x5b, 0x6e, 0xfe,
	0x2f, 0x65, 0x52, 0x2a, 0x2b, 0x8b, 0xb1, 0x9a, 0x3d, 0x85, 0xed, 0x88, 0xab, 0xa2, 0xd5, 0x58,
	0x2a, 0x74, 0xb3, 0xe7, 0x92, 0x03, 0x28, 0xf5, 0xa6, 0x2d, 0xd7, 0x65, 0xc8, 0xb9, 0x72, 0x5b,
	0xa2, 0x0b, 0x86, 0x4c, 0xf8, 0x99, 0xcf, 0xdb, 0xc8, 0x44, 0x3d, 0xa7, 0x64, 0x11, 0x29, 0xef,
	0x0d, 0xbd, 0x8b, 0xc0, 0x11, 0x33, 0x26, 0x3f, 0x86, 0x34, 0xb7, 0x60, 0xd8, 0x7d, 0xa8, 0xb6,
	0x7d, 0x0f, 0x03, 0x41, 0xf1, 0xf5, 0x0c, 0xb9, 0x20, 0x77, 0xa0, 0xf8, 0x82, 0x23, 0x33, 0x89,
	0xae, 0x50, 0x43, 0x91, 0x8f, 0xa1, 0xfa, 0xcc, 0xe1, 0xa2, 0xaf, 0xd1, 0xf7, 0x3a, 0x06, 0x42,
	0x9a, 0x69, 0x37, 0xa0, 0xd8, 0xeb, 0x3c, 0xf3, 0xb8, 0x90, 0xf9, 0xe9, 0x75, 0x74, 0xbd, 0x96,
	0xa8, 0x3c, 0xda, 0x4f, 0xa0, 0xd2, 0x19, 0xb6, 0x16, 0xf9, 0xae, 0x80, 0xf5, 0xd2, 0x38, 0xb1,
	0x5e, 0x4a, 0x6a, 0x60, 0xb2, 0x69, 0x0d, 0x24, 0xf5, 0x5c, 0x05, 0x52, 0xa1, 0xd6, 0x73, 0x49,
	0x75, 0x0d, 0x74, 0xab, 0x6b, 0x7f, 0xab, 0xec, 0xc4, 0x21, 0x10, 0x02, 0xf9, 0xa7, 0x0e, 0x1f,
	0x1b, 0x53, 0xea, 0x2c, 0x6f, 0xd0, 0xc8, 0x1a, 0x95, 0xd4, 0x30, 0xb2, 0x36, 0xb4, 0x5f, 0x43,
	0x4d, 0xc6, 0x44, 0xf1, 0xc2, 0xe3, 0x82, 0x39, 0xc2, 0x0b, 0x03, 0xf2, 0x05, 0xd4, 0x92, 0x74,
	0x3b, 0x74, 0x75, 0xe1, 0x94, 0xe8, 0x0a, 0x9f, 0xdc, 0x87, 0xa2, 0x4e, 0x99, 0x69, 0xbb, 0xbb,
	0xa9, 0xaf, 0x9a, 0x0c, 0x91, 0x1a, 0x45, 0xfb, 0x17, 0x0b, 0x0e, 0x96, 0x7d, 0xb6, 0xc3, 0xe0,
	0xdc, 0x63, 0x13, 0xed, 0xbf, 0x0f, 0x7b, 0x5a, 0x55, 0x86, 0x85, 0xee, 0xf1, 0x5c, 0x37, 0xaa,
	0x29, 0xc5, 0x15, 0x0f, 0x71, 0xf0, 0x34, 0xf3, 0x9a, 0x1c, 0x17, 0x8f, 0x19, 0x0b, 0x99, 0xf9,
	0x48, 0x9a, 0xb0, 0x7f, 0xb5, 0x64, 0x85, 0x06, 0x23, 0x8c, 0xbe, 0x35, 0x81, 0xfc, 0xd0, 0xf1,
	0x45, 0x94, 0x39, 0x79, 0xfe, 0x80, 0xe8, 0xd6, 0x82, 0xcf, 0x7d, 0x10, 0x78, 0xfb, 0x01, 0x14,
	0x14, 0x4a, 0x19, 0x85, 0x3a, 0x18, 0x7c, 0x0b, 0x6e, 0x46, 0x6c, 0xbf, 0x5b, 0x50, 0xff, 0xaf,
	0xb2, 0x7b, 0x1f, 0x8a, 0xc6, 0xc0, 0xbb, 0x53, 0xb4, 0xfc, 0x41, 0x72, 0x49, 0xd0, 0xfb, 0x90,
	0x6b, 0x8d, 0x2e, 0x17, 0x42, 0x2b, 0x29, 0x7c, 0x0b, 0x85, 0x63, 0x47, 0x8c, 0xc6, 0xef, 0x39,
	0x97, 0x1a, 0xb0, 0xfd, 0x24, 0x64, 0x83, 0xb1, 0xc3, 0x51, 0xc1, 0x2b, 0xd0, 0x98, 0x26, 0x9f,
	0x41, 0x81, 0xfb, 0xa1, 0xe0, 0x6a, 0x5c, 0x97, 0x9b, 0xbb, 0x29, 0x4b, 0x43, 0x3f, 0x14, 0x54,
	0xcb, 0x6d, 0x0e, 0x25, 0xe5, 0x5b, 0x0d, 0xa2, 0x7f, 0xcf, 0xff, 0x81, 0x31, 0xab, 0xe6, 0x72,
	0x4e, 0xcd, 0xe5, 0x05, 0xc3, 0xfe, 0x2b, 0x07, 0x79, 0x09, 0x42, 0xe6, 0xa3, 0x17, 0xb8, 0xf8,
	0xc6, 0x8c, 0x6e, 0x4d, 0x90, 0x26, 0xec, 0x3d, 0x0e, 0x46, 0x6c, 0x3e, 0x15, 0xe8, 0x9a, 0x81,
	0x73, 0x82, 0x73, 0x6e, 0xba, 0x3c, 0x53, 0x46, 0xbe, 0x87, 0xfd, 0x98, 0xdf, 0xe2, 0x3c, 0x1c,
	0x79, 0x8e, 0x40, 0xb7, 0xe3, 0x08, 0x47, 0x5d, 0xd5, 0x23, 0xe1, 0x3a, 0x15, 0xf2, 0x10, 0xea,
	0x03, 0x87, 0x09, 0xcf, 0xf1, 0x8d, 0xdd, 0xf6, 0x7c, 0x3a, 0x46, 0x76, 0x86, 0x6f, 0x84, 0x99,
	0x48, 0x6b, 0xe5, 0xe4, 0x29, 0x7c, 0x64, 0x64, 0x69, 0xc3, 0x09, 0x13, 0x05, 0x65, 0xe2, 0x5d,
	0x6a, 0x32, 0x0e, 0xa3, 0x92, 0x78, 0xb3, 0xb4, 0x5c, 0x3e, 0x42, 0x45, 0x1d, 0xc7, 0x35, 0x2a,
	0xf2, 0xb3, 0x0c, 0x31, 0x70, 0xd5, 0x60, 0xdf, 0x52, 0xea, 0x31, 0x4d, 0x3e, 0x85, 0x1d, 0x03,
	0x7e, 0xe0, 0xcc, 0xfd, 0xd0, 0x71, 0xeb, 0xdb, 0x4a, 0x63, 0x89, 0x2b, 0xf5, 0xd2, 0x08, 0xeb,
	0x25, 0xad, 0x97, 0xe6, 0xc6, 0x63, 0x05, 0x12, 0x63, 0x65, 0x0f, 0x0a, 0x27, 0xfd, 0x56, 0x9b,
	0xd7, 0xcb, 0x87, 0x39, 0xd9, 0xcb, 0x8a, 0x68, 0xfe, 0xb1, 0x05, 0x79, 0xf9, 0xe0, 0x91, 0x26,
	0x94, 0x5a, 0xfc, 0xf2, 0x87, 0xc0, 0xf7, 0x02, 0x24, 0xe9, 0xba, 0x94, 0xfb, 0x4f, 0xa3, 0x96,
	0x62, 0xb5, 0x46, 0x97, 0xf6, 0x06, 0x79, 0x08, 0x55, 0x15, 0xaa, 0x60, 0xde, 0x54, 0x2d, 0x49,
	0xe9, 0xe7, 0x35, 0xda, 0x9d, 0x32, 0xef, 0x1e, 0x43, 0xad, 0x8b, 0x62, 0x69, 0x1b, 0x4a, 0xb7,
	0x43, 0x52, 0x96, 0x69, 0xe3, 0x6b, 0xd8, 0x69, 0x33, 0x74, 0x04, 0x9e, 0xe2, 0x95, 0xae, 0xfd,
	0x35, 0xad, 0x91, 0x79, 0xfb, 0x2b, 0xa8, 0x0c, 0x42, 0x2e, 0x4e, 0xf1, 0x4a, 0x77, 0x39, 0x49,
	0xe9, 0x28, 0xde, 0x3a, 0xaf, 0x4f, 0xbc, 0xc0, 0xe3, 0x63, 0x8a, 0x8e, 0x2f, 0xbc, 0x09, 0xbe,
	0x97, 0xd7, 0x07, 0x50, 0x92, 0x5e, 0x75, 0x3b, 0xde, 0xd4, 0xe5, 0x43, 0xb8, 0x35, 0x14, 0x0c,
	0x9d, 0xc9, 0xe2, 0xea, 0xea, 0xe8, 0xc8, 0xba, 0x79, 0x64, 0x11, 0x0a, 0xa4, 0x8b, 0x62, 0x79,
	0x4d, 0x3b, 0x58, 0x85, 0xbc, 0x90, 0x36, 0xae, 0x95, 0xda, 0x1b, 0xe4, 0x3b, 0xa8, 0x98, 0x17,
	0x4c, 0xbf, 0x08, 0x77, 0x97, 0xd6, 0xaa, 0xc5, 0x0b, 0xd7, 0x20, 0xab, 0x22, 0x7b, 0x83, 0xbc,
	0x84, 0xdb, 0xe6, 0x7d, 0x48, 0x2d, 0x01, 0xeb, 0x1f, 0x82, 0xc6, 0x27, 0x69, 0x48, 0x6b, 0x1e,
	0x1a, 0x7b, 0x83, 0x3c, 0x06, 0x22, 0xb3, 0xb4, 0xb4, 0x5a, 0xee, 0xaf, 0x46, 0x14, 0x0b, 0x33,
	0x53, 0xfe, 0x08, 0x76, 0x55, 0xb2, 0x19, 0x8e, 0xc2, 0xc9, 0x94, 0x22, 0x9f, 0xf9, 0xe2, 0x3d,
	0x4a, 0x64, 0xb7, 0x8b, 0xa2, 0x1d, 0x4e, 0xa6, 0x3e, 0x0a, 0x74, 0x75, 0x7d, 0x65, 0x34, 0x55,
	0x86, 0x3d, 0x7b, 0x83, 0xb4, 0xa0, 0xd6, 0x09, 0xaf, 0x02, 0xd9, 0xf1, 0xf1, 0x2a, 0x7b, 0x77,
	0x65, 0x71, 0x8d, 0x44, 0x59, 0x00, 0x9a, 0x7f, 0x6e, 0xc2, 0x56, 0xd7, 0x11, 0x78, 0xe5, 0xcc,
	0xc9, 0x31, 0x54, 0xdb, 0x63, 0x1c, 0x5d, 0x9a, 0x59, 0xb2, 0xdc, 0x66, 0xa9, 0xe5, 0xb3, 0x71,
	0x3b, 0x25, 0xd3, 0x9b, 0xa4, 0xbd, 0x41, 0xbe, 0x01, 0xe8, 0x62, 0xb4, 0x65, 0x5e, 0x6b, 0x60,
	0xb5, 0x2e, 0x55, 0xd1, 0xc3, 0x60, 0x16, 0x5f, 0xbf, 0x59, 0xe9, 0xfe, 0xf3, 0x22, 0xa3, 0x50,
	0x31, 0xb5, 0x91, 0x65, 0xe0, 0x83, 0xaa, 0xab, 0xf9, 0x93, 0x04, 0x95, 0xa8, 0xd8, 0x1f, 0x23,
	0x1a, 0x99, 0x5c, 0x2f, 0xc9, 0xff, 0x53, 0x86, 0x96, 0x37, 0xce, 0xc6, 0xe7, 0xd7, 0x8a, 0xd3,
	0xbe, 0x5e, 0x15, 0xd5, 0xaf, 0xe9, 0x83, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x9c, 0x40, 0x88,
	0x22, 0xaf, 0x0e, 0x00, 0x00,
}
